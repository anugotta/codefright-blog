[{"content":"Been working with KMM for a while. Used it on a project where we needed to share business logic between Android and iOS while keeping native UIs. Worked out well, had some bumps along the way.\nWhat is Kotlin Multiplatform Mobile? KMM lets you write business logic in Kotlin and share it between Android and iOS. You keep native UIs on each platform, which is important for performance and user experience. The shared code handles things like API calls, data models, and business rules.\nThe main benefits:\nWrite business logic once, use it on both platforms Keep native UIs for better performance Less code duplication means fewer bugs Faster development when you need features on both platforms Setting Up Your Project Setting up a KMM project can be tricky the first time. What you need in root build.gradle:\nbuildscript { repositories { google() mavenCentral() } dependencies { classpath(\u0026#34;org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.20\u0026#34;) classpath(\u0026#34;com.android.tools.build:gradle:8.1.0\u0026#34;) } } The project structure is important. It should look like this:\nMyKMMProject/ ├── androidApp/ ├── iosApp/ └── shared/ ├── src/ ├── commonMain/ ├── androidMain/ └── iosMain/ Writing Your First Shared Code Simplest thing to share is data models. These work the same on both platforms:\n// commonMain/kotlin/com/example/User.kt data class User( val id: String, val name: String, val email: String ) For platform-specific code, you use expect and actual. This is how you access platform APIs:\n// commonMain/kotlin/com/example/Platform.kt expect class Platform() { val platform: String } // androidMain/kotlin/com/example/Platform.kt actual class Platform actual constructor() { actual val platform: String = \u0026#34;Android ${android.os.Build.VERSION.SDK_INT}\u0026#34; } // iosMain/kotlin/com/example/Platform.kt actual class Platform actual constructor() { actual val platform: String = UIDevice.currentDevice.systemName() } Shared Networking with Ktor For networking, use Ktor. Works well with KMM. Basic setup:\nclass ApiClient { private val httpClient = HttpClient { install(ContentNegotiation) { json() } } suspend fun fetchUser(id: String): User { return httpClient.get(\u0026#34;https://api.example.com/users/$id\u0026#34;).body() } } Platform-Specific UI Android UI class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { UserProfile() } } } @Composable fun UserProfile() { var user by remember { mutableStateOf\u0026lt;User?\u0026gt;(null) } LaunchedEffect(Unit) { user = ApiClient().fetchUser(\u0026#34;123\u0026#34;) } Column { Text(user?.name ?: \u0026#34;Loading...\u0026#34;) Text(user?.email ?: \u0026#34;\u0026#34;) } } iOS UI struct ContentView: View { @State private var user: User? = nil var body: some View { VStack { Text(user?.name ?? \u0026#34;Loading...\u0026#34;) Text(user?.email ?? \u0026#34;\u0026#34;) } .onAppear { ApiClient().fetchUser(id: \u0026#34;123\u0026#34;) { fetchedUser in user = fetchedUser } } } } Issues I Ran Into 1. Threading differences\nAndroid and iOS handle threads differently. Code that worked on Android crashed on iOS. For shared code, use Dispatchers.Default:\nclass UserRepository { suspend fun getUser(id: String) = withContext(Dispatchers.Default) { // This works on both platforms api.fetchUser(id) } } 2. Memory management\niOS uses ARC, Android uses garbage collection. Different, but for most shared code you don\u0026rsquo;t need to worry. Just be aware memory behavior might differ slightly.\n3. Platform-specific APIs\nCan\u0026rsquo;t use Android or iOS APIs directly in shared code. Seems obvious, but tried it anyway:\n// DON\u0026#39;T do this in commonMain fun getPlatformVersion() = Build.VERSION.SDK_INT // Won\u0026#39;t work! // DO this instead expect fun getPlatformVersion(): String actual fun getPlatformVersion() = Build.VERSION.SDK_INT.toString() Example: Image Loading Needed to load images in shared code. How we handled it:\ninterface ImageLoader { suspend fun loadImage(url: String): ImageBitmap } class AndroidImageLoader : ImageLoader { override suspend fun loadImage(url: String): ImageBitmap = withContext(Dispatchers.IO) { URL(url).openStream().use { BitmapFactory.decodeStream(it).asImageBitmap() } } } class IosImageLoader : ImageLoader { override suspend fun loadImage(url: String): ImageBitmap = withContext(Dispatchers.Default) { NSUrl(string = url)?.let { nsUrl -\u0026gt; NSData.dataWithContentsOfURL(nsUrl)?.toUIImage()?.toImageBitmap() } ?: throw IllegalArgumentException(\u0026#34;Invalid URL\u0026#34;) } } Testing Shared Code Testing KMM code is straightforward - it\u0026rsquo;s just Kotlin, use standard testing libraries:\nclass UserRepositoryTest { @Test fun testFetchUser() = runTest { val repository = UserRepository(mockApi) val user = repository.getUser(\u0026#34;123\u0026#34;) assertEquals(\u0026#34;John Doe\u0026#34;, user.name) } } My Take on KMM KMM isn\u0026rsquo;t perfect. Tooling can be rough, especially for iOS. Setting up the project takes time, debugging can be tricky when something works on one platform but not the other. When it works, it\u0026rsquo;s great - write business logic once, runs on both platforms.\nIs it worth it? For us, yes. Had complex business logic that needed to be identical on both platforms. KMM let us write it once and test it once, saved a lot of time.\nIf building a simple app, KMM might be overkill. If you have complex shared logic, worth considering. Ecosystem is still evolving, getting better.\nCheck out the official KMM documentation for more details.\n","permalink":"https://www.codefright.com/posts/kmm-guide/","summary":"Been working with KMM for a while. Used it on a project where we needed to share business logic between Android and iOS while keeping native UIs. Worked out well, had some bumps along the way.\nWhat is Kotlin Multiplatform Mobile? KMM lets you write business logic in Kotlin and share it between Android and iOS. You keep native UIs on each platform, which is important for performance and user experience.","title":"⚡ Getting Started with Kotlin Multiplatform Mobile"},{"content":"This guide is also available as a comprehensive GitHub repository:\nCore Android Concepts Activities \u0026amp; Fragments Activity Lifecycle onCreate(): Activity is first created\nInitialize UI Set content view Initialize variables onStart(): Activity becomes visible\nPrepare UI elements Register broadcast receivers onResume(): Activity starts interacting with user\nStart animations/video playback Initialize foreground services onPause(): Activity partially visible but not focused\nPause ongoing operations Save draft data onStop(): Activity no longer visible\nSave persistent data Release resources onDestroy(): Activity being destroyed\nCleanup resources Unregister receivers Common Flows:\nNormal Flow: onCreate → onStart → onResume → onPause → onStop → onDestroy Background Flow: onStop → onRestart → onStart Configuration Change: onPause → onSaveInstanceState → onStop → onDestroy → onCreate → onStart → onRestoreInstanceState → onResume Fragment Lifecycle Complete Flow: onAttach → onCreate → onCreateView → onViewCreated → onActivityCreated → onStart → onResume → onPause → onStop → onDestroyView → onDestroy → onDetach Key Methods:\nonAttach(): Fragment attached to activity onCreateView(): Create and return view hierarchy onViewCreated(): View setup after creation onDestroyView(): View hierarchy being destroyed Services Types of Services Foreground Service class MusicService : Service() { override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { val notification = createNotification() startForeground(NOTIFICATION_ID, notification) return START_STICKY } } Background Service class DataSyncService : Service() { override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { // Perform background operation return START_NOT_STICKY } } Bound Service class LocalService : Service() { private val binder = LocalBinder() inner class LocalBinder : Binder() { fun getService(): LocalService = this@LocalService } override fun onBind(intent: Intent): IBinder = binder } IntentService (Deprecated, use WorkManager instead) class DataProcessingService : IntentService(\u0026#34;DataProcessingService\u0026#34;) { override fun onHandleIntent(intent: Intent?) { // Process data in background } } Intents \u0026amp; Communication Types of Intents Explicit Intents // Start specific activity val intent = Intent(context, TargetActivity::class.java) intent.putExtra(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) startActivity(intent) Implicit Intents // Open URL val intent = Intent(Intent.ACTION_VIEW, Uri.parse(\u0026#34;https://example.com\u0026#34;)) startActivity(intent) // Share text val shareIntent = Intent().apply { action = Intent.ACTION_SEND type = \u0026#34;text/plain\u0026#34; putExtra(Intent.EXTRA_TEXT, \u0026#34;Share this\u0026#34;) } startActivity(Intent.createChooser(shareIntent, \u0026#34;Share via\u0026#34;)) Broadcast Receivers Static Receiver (Manifest-declared) \u0026lt;receiver android:name=\u0026#34;.MyReceiver\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.BOOT_COMPLETED\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; Dynamic Receiver (Runtime registration) private val receiver = object : BroadcastReceiver() { override fun onReceive(context: Context, intent: Intent) { // Handle broadcast } } override fun onResume() { super.onResume() registerReceiver(receiver, IntentFilter(\u0026#34;ACTION_NAME\u0026#34;)) } override fun onPause() { super.onPause() unregisterReceiver(receiver) } Kotlin Fundamentals Key Features Null Safety // Nullable types var nullableString: String? = null // Safe call operator nullableString?.length // Elvis operator val length = nullableString?.length ?: 0 // Not-null assertion val definiteLength = nullableString!!.length // Throws if null Properties // Lazy initialization val expensive: String by lazy { // Computed only on first access computeExpensiveString() } // Late initialization lateinit var lateinitVar: String // Initialize later lateinitVar = \u0026#34;Now initialized\u0026#34; // Custom getters/setters var counter = 0 get() = field set(value) { if (value \u0026gt;= 0) field = value } Modern Android Development Jetpack Compose Basic Composables @Composable fun Greeting(name: String) { Column { Text(text = \u0026#34;Hello $name!\u0026#34;) Button(onClick = { /* action */ }) { Text(\u0026#34;Click me\u0026#34;) } } } State Management // Local state @Composable fun Counter() { var count by remember { mutableStateOf(0) } Button(onClick = { count++ }) { Text(\u0026#34;Count: $count\u0026#34;) } } // Hoisted state @Composable fun StatefulCounter( count: Int, onCountChange: (Int) -\u0026gt; Unit ) { Button(onClick = { onCountChange(count + 1) }) { Text(\u0026#34;Count: $count\u0026#34;) } } Side Effects @Composable fun MyScreen() { // Run on first composition LaunchedEffect(Unit) { // Launch coroutine } // Run on every successful composition SideEffect { // Update non-compose code } // Cleanup when leaving composition DisposableEffect(Unit) { onDispose { // Cleanup } } } Navigation Component Navigation Graph \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;navigation xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; android:id=\u0026#34;@+id/nav_graph\u0026#34; app:startDestination=\u0026#34;@id/homeFragment\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/homeFragment\u0026#34; android:name=\u0026#34;.HomeFragment\u0026#34;\u0026gt; \u0026lt;action android:id=\u0026#34;@+id/to_detail\u0026#34; app:destination=\u0026#34;@id/detailFragment\u0026#34;\u0026gt; \u0026lt;argument android:name=\u0026#34;itemId\u0026#34; app:argType=\u0026#34;string\u0026#34; /\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/fragment\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/detailFragment\u0026#34; android:name=\u0026#34;.DetailFragment\u0026#34; /\u0026gt; \u0026lt;/navigation\u0026gt; Navigation in Code // Using Safe Args class HomeFragment : Fragment() { private val navArgs: HomeFragmentArgs by navArgs() fun navigate() { val action = HomeFragmentDirections.toDetail(itemId = \u0026#34;123\u0026#34;) findNavController().navigate(action) } } Architecture Components MVVM Pattern // Model data class User(val id: String, val name: String) // ViewModel class UserViewModel : ViewModel() { private val _user = MutableLiveData\u0026lt;User\u0026gt;() val user: LiveData\u0026lt;User\u0026gt; = _user fun loadUser(id: String) { viewModelScope.launch { _user.value = repository.getUser(id) } } } // View class UserFragment : Fragment() { private val viewModel: UserViewModel by viewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewModel.user.observe(viewLifecycleOwner) { user -\u0026gt; // Update UI } } } State Management StateFlow class UserViewModel : ViewModel() { private val _uiState = MutableStateFlow\u0026lt;UiState\u0026gt;(UiState.Initial) val uiState: StateFlow\u0026lt;UiState\u0026gt; = _uiState.asStateFlow() fun loadData() { viewModelScope.launch { _uiState.value = UiState.Loading try { val result = repository.getData() _uiState.value = UiState.Success(result) } catch (e: Exception) { _uiState.value = UiState.Error(e.message) } } } } // States sealed class UiState { object Initial : UiState() object Loading : UiState() data class Success(val data: Data) : UiState() data class Error(val message: String?) : UiState() } Room Database // Entity @Entity(tableName = \u0026#34;users\u0026#34;) data class UserEntity( @PrimaryKey val id: String, val name: String, val email: String ) // DAO @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM users\u0026#34;) fun getAll(): Flow\u0026lt;List\u0026lt;UserEntity\u0026gt;\u0026gt; @Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(user: UserEntity) @Delete suspend fun delete(user: UserEntity) } // Database @Database(entities = [UserEntity::class], version = 1) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao } Dependency Injection with Hilt // Application class @HiltAndroidApp class MyApplication : Application() // Module @Module @InstallIn(SingletonComponent::class) object AppModule { @Provides @Singleton fun provideDatabase(@ApplicationContext context: Context): AppDatabase { return Room.databaseBuilder( context, AppDatabase::class.java, \u0026#34;app_database\u0026#34; ).build() } } // ViewModel injection @HiltViewModel class MainViewModel @Inject constructor( private val repository: Repository ) : ViewModel() // Activity injection @AndroidEntryPoint class MainActivity : AppCompatActivity() Background Processing Coroutines class MainViewModel : ViewModel() { // Different Coroutine Scopes init { // ViewModel Scope viewModelScope.launch { // Runs on Main dispatcher by default } // Background work with IO dispatcher viewModelScope.launch(Dispatchers.IO) { // Network or database operations } // CPU-intensive work viewModelScope.launch(Dispatchers.Default) { // Complex calculations } } // Parallel Execution suspend fun loadDataInParallel() { coroutineScope { val result1 = async { api.getData1() } val result2 = async { api.getData2() } val combinedResult = result1.await() + result2.await() } } } WorkManager // Define Work class DataSyncWorker( context: Context, params: WorkerParameters ) : CoroutineWorker(context, params) { override suspend fun doWork(): Result { return try { // Do background work Result.success() } catch (e: Exception) { Result.retry() } } } // Schedule Work class Repository { fun scheduleSync() { val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .setRequiresBatteryNotLow(true) .build() val syncWork = OneTimeWorkRequestBuilder\u0026lt;DataSyncWorker\u0026gt;() .setConstraints(constraints) .setBackoffCriteria(BackoffPolicy.LINEAR, 10, TimeUnit.MINUTES) .build() WorkManager.getInstance(context) .enqueueUniqueWork( \u0026#34;sync_work\u0026#34;, ExistingWorkPolicy.REPLACE, syncWork ) } } RxJava // Basic Observable Observable.just(1, 2, 3, 4, 5) .map { it * 2 } .filter { it \u0026gt; 5 } .subscribe { println(it) } // Network Call with RxJava interface ApiService { @GET(\u0026#34;users\u0026#34;) fun getUsers(): Single\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; } class Repository { fun getUsers(): Single\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; { return apiService.getUsers() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) } } Data Management Secure Data Storage // Encrypted Shared Preferences val masterKey = MasterKey.Builder(context) .setKeyScheme(MasterKey.KeyScheme.AES256_GCM) .build() val sharedPreferences = EncryptedSharedPreferences.create( context, \u0026#34;secret_prefs\u0026#34;, masterKey, EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV, EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM ) // Encrypted Files val encryptedFile = EncryptedFile.Builder( context, File(context.filesDir, \u0026#34;secret.txt\u0026#34;), masterKey, EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB ).build() Network Security // Certificate Pinning with OkHttp val certificatePinner = CertificatePinner.Builder() .add(\u0026#34;example.com\u0026#34;, \u0026#34;sha256/XXXX=\u0026#34;) .build() val okHttpClient = OkHttpClient.Builder() .certificatePinner(certificatePinner) .build() // Retrofit with Security val retrofit = Retrofit.Builder() .baseUrl(\u0026#34;https://api.example.com/\u0026#34;) .client(okHttpClient) .addConverterFactory(GsonConverterFactory.create()) .build() Testing Unit Testing @Test fun `test user validation`() { val validator = UserValidator() assertTrue(validator.isValidEmail(\u0026#34;test@example.com\u0026#34;)) assertFalse(validator.isValidEmail(\u0026#34;invalid-email\u0026#34;)) } // ViewModel Testing @Test fun `test loading state`() = runTest { val repository = mockk\u0026lt;Repository\u0026gt;() coEvery { repository.getData() } returns Result.success(data) val viewModel = MainViewModel(repository) viewModel.loadData() assertEquals(UiState.Success(data), viewModel.uiState.value) } UI Testing with Espresso @Test fun testLoginFlow() { // Launch activity ActivityScenario.launch(LoginActivity::class.java) // Type text onView(withId(R.id.emailInput)) .perform(typeText(\u0026#34;test@example.com\u0026#34;)) // Click button onView(withId(R.id.loginButton)) .perform(click()) // Verify text onView(withId(R.id.statusText)) .check(matches(withText(\u0026#34;Success\u0026#34;))) } Compose UI Testing @Test fun testCounter() { composeTestRule.setContent { Counter() } composeTestRule .onNodeWithText(\u0026#34;Count: 0\u0026#34;) .assertExists() .performClick() composeTestRule .onNodeWithText(\u0026#34;Count: 1\u0026#34;) .assertExists() } Performance Optimization Memory Management class MainActivity : AppCompatActivity() { // Avoid memory leaks with weak references private val weakReference = WeakReference(this) // Proper bitmap handling private fun loadBitmap() { val options = BitmapFactory.Options().apply { inJustDecodeBounds = true } BitmapFactory.decodeResource(resources, R.drawable.image, options) options.apply { inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight) inJustDecodeBounds = false } } } // Memory Cache class ImageCache { private val memoryCache = object : LruCache\u0026lt;String, Bitmap\u0026gt;( (Runtime.getRuntime().maxMemory() / 1024).toInt() / 8 ) { override fun sizeOf(key: String, bitmap: Bitmap): Int { return bitmap.byteCount / 1024 } } } Build \u0026amp; Deployment Gradle Configuration // App level build.gradle.kts plugins { id(\u0026#34;com.android.application\u0026#34;) id(\u0026#34;kotlin-android\u0026#34;) id(\u0026#34;kotlin-kapt\u0026#34;) id(\u0026#34;dagger.hilt.android.plugin\u0026#34;) } android { defaultConfig { applicationId = \u0026#34;com.example.app\u0026#34; minSdk = 24 targetSdk = 34 versionCode = 1 versionName = \u0026#34;1.0.0\u0026#34; } buildTypes { release { isMinifyEnabled = true proguardFiles(getDefaultProguardFile(\u0026#34;proguard-android.txt\u0026#34;), \u0026#34;proguard-rules.pro\u0026#34;) } debug { applicationIdSuffix = \u0026#34;.debug\u0026#34; isDebuggable = true } } buildFeatures { compose = true viewBinding = true } } APK vs App Bundle // App Bundle benefits: // 1. Smaller download size // 2. Dynamic feature delivery // 3. Optimized for different devices // Configure dynamic feature android { dynamicFeatures = mutableSetOf(\u0026#34;:feature_module\u0026#34;) } // Install dynamic feature class MainActivity : AppCompatActivity() { private fun installFeature() { val request = SplitInstallRequest.newBuilder() .addModule(\u0026#34;feature_module\u0026#34;) .build() splitInstallManager.startInstall(request) .addOnSuccessListener { /* Handle success */ } .addOnFailureListener { /* Handle failure */ } } } CI/CD Pipeline # Example GitHub Actions workflow name: Android CI on: push: branches: [ main ] pull_request: branches: [ main ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up JDK uses: actions/setup-java@v2 with: java-version: \u0026#39;11\u0026#39; - name: Run Tests run: ./gradlew test - name: Build Debug APK run: ./gradlew assembleDebug - name: Upload APK uses: actions/upload-artifact@v2 with: name: app-debug path: app/build/outputs/apk/debug/app-debug.apk Data Structures \u0026amp; Algorithms Common Interview Problems 1. String Manipulation // Reverse String fun reverseString(str: String): String { return str.reversed() // Or manual implementation: return str.toCharArray() .apply { reverse() } .joinToString(\u0026#34;\u0026#34;) } // Check Palindrome fun isPalindrome(str: String): Boolean { val cleanStr = str.lowercase().filter { it.isLetterOrDigit() } return cleanStr == cleanStr.reversed() } 2. Array Operations // Find Missing Number fun findMissingNumber(arr: IntArray): Int { val n = arr.size + 1 val expectedSum = (n * (n + 1)) / 2 val actualSum = arr.sum() return expectedSum - actualSum } // Maximum Subarray Sum fun maxSubArraySum(arr: IntArray): Int { var maxSoFar = arr[0] var maxEndingHere = arr[0] for (i in 1 until arr.size) { maxEndingHere = maxOf(arr[i], maxEndingHere + arr[i]) maxSoFar = maxOf(maxSoFar, maxEndingHere) } return maxSoFar } 3. Linked List Operations data class ListNode( var value: Int, var next: ListNode? = null ) // Reverse Linked List fun reverseList(head: ListNode?): ListNode? { var prev: ListNode? = null var current = head while (current != null) { val next = current.next current.next = prev prev = current current = next } return prev } // Detect Cycle fun hasCycle(head: ListNode?): Boolean { var slow = head var fast = head while (fast?.next != null) { slow = slow?.next fast = fast.next?.next if (slow == fast) return true } return false } Android-Specific Optimizations 1. View Hierarchy Optimization // Flatten view hierarchy \u0026lt;merge xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!-- Child views --\u0026gt; \u0026lt;/merge\u0026gt; // Use ConstraintLayout for complex layouts \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;!-- Constraints reduce nesting --\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 2. RecyclerView Optimization class OptimizedAdapter : RecyclerView.Adapter\u0026lt;ViewHolder\u0026gt;() { // Implement DiffUtil private val diffCallback = object : DiffUtil.ItemCallback\u0026lt;Item\u0026gt;() { override fun areItemsTheSame(oldItem: Item, newItem: Item): Boolean { return oldItem.id == newItem.id } override fun areContentsTheSame(oldItem: Item, newItem: Item): Boolean { return oldItem == newItem } } // Use ListAdapter for automatic diff class EfficientAdapter : ListAdapter\u0026lt;Item, ViewHolder\u0026gt;(diffCallback) // View pool for shared ViewHolders init { setHasStableIds(true) recyclerView.setRecycledViewPool(viewPool) } } Best Practices \u0026amp; Tips Code Quality // Use meaningful names fun processUserData() instead of fun process() // Single Responsibility Principle class UserRepository { fun getUser() // Only user-related operations } // Dependency Injection over direct instantiation class MyViewModel @Inject constructor( private val repository: Repository ) // Error Handling sealed class Result\u0026lt;out T\u0026gt; { data class Success\u0026lt;T\u0026gt;(val data: T) : Result\u0026lt;T\u0026gt;() data class Error(val exception: Exception) : Result\u0026lt;Nothing\u0026gt;() } Security Best Practices // Secure data storage private fun storeSecurely(data: String) { val encryptedData = encrypt(data) securePreferences.edit().putString(\u0026#34;key\u0026#34;, encryptedData).apply() } // Network security private fun configureNetworkSecurity() { // Force HTTPS android:usesCleartextTraffic=\u0026#34;false\u0026#34; // Certificate pinning val certificatePinner = CertificatePinner.Builder() .add(\u0026#34;example.com\u0026#34;, \u0026#34;sha256/XXXX=\u0026#34;) .build() } Performance Tips // Lazy loading private val expensiveObject by lazy { // Created only when first accessed ExpensiveObject() } // Efficient image loading private fun loadImageEfficiently() { Glide.with(context) .load(imageUrl) .transition(DrawableTransitionOptions.withCrossFade()) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(imageView) } Additional Resources Keep up with Android Developers Blog Follow Android Dev Summit Practice with Android Code Labs Read official Material Design Guidelines Join Android development communities on Reddit and Stack Overflow ","permalink":"https://www.codefright.com/posts/interview-guide/","summary":"This guide is also available as a comprehensive GitHub repository:\nCore Android Concepts Activities \u0026amp; Fragments Activity Lifecycle onCreate(): Activity is first created\nInitialize UI Set content view Initialize variables onStart(): Activity becomes visible\nPrepare UI elements Register broadcast receivers onResume(): Activity starts interacting with user\nStart animations/video playback Initialize foreground services onPause(): Activity partially visible but not focused\nPause ongoing operations Save draft data onStop(): Activity no longer visible","title":"⚡ Android Developer Interview Guide"},{"content":"Been using XML for Android UIs for over a decade. When Jetpack Compose came out, I was very interested to learn this. After using it in production for a couple of years, I prefer it over XML for most cases.\nWhat is Jetpack Compose? Compose lets you build UIs using Kotlin functions instead of XML. You write functions that return UI instead of layout files. It\u0026rsquo;s declarative - you describe what you want, Compose handles the rendering.\nGetting Started Add these dependencies to use Compose. Using version 1.5.4 here, check for latest:\ndependencies { implementation \u0026#34;androidx.compose.ui:ui:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.material:material:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.ui:ui-tooling-preview:1.5.4\u0026#34; } Your First Composable Simple composable example:\n@Composable fun WelcomeText(name: String) { Text(\u0026#34;Hey $name, welcome to Compose!\u0026#34;) } The @Composable annotation makes it work. Compose tracks the function and manages its lifecycle. Call it like any function, it renders UI instead of returning a value.\nState Management When state changes, Compose automatically recomposes the affected UI parts. Simple counter example:\n@Composable fun Counter() { var count by remember { mutableStateOf(0) } Column(modifier = Modifier.padding(16.dp)) { Text(\u0026#34;You clicked $count times\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Click me\u0026#34;) } } } Modifiers Modifiers apply styling and behavior to composables. They work as a chain of transformations. Order matters - padding().fillMaxWidth() is different from fillMaxWidth().padding():\n@Composable fun StyledButton( text: String, onClick: () -\u0026gt; Unit ) { Button( onClick = onClick, modifier = Modifier .padding(16.dp) .fillMaxWidth() .height(48.dp) ) { Text(text) } } Common Mistakes 1. Forgetting remember for state\nIf you don\u0026rsquo;t use remember, state resets every time the composable recomposes:\n// This won\u0026#39;t work - count resets to 0 on every recomposition @Composable fun Counter() { var count = mutableStateOf(0) // Bad! Button(onClick = { count.value++ }) { Text(\u0026#34;Count: ${count.value}\u0026#34;) } } // This works - state persists across recompositions @Composable fun Counter() { var count by remember { mutableStateOf(0) } // Good! Button(onClick = { count++ }) { Text(\u0026#34;Count: $count\u0026#34;) } } 2. Updating UI from background thread\nCompose UI must be updated from the main thread. This will crash your app:\nLaunchedEffect(key1 = true) { withContext(Dispatchers.IO) { // Fetching data on background thread - good val data = api.fetchData() // But you can\u0026#39;t update state here - it will crash // uiState = data // DON\u0026#39;T DO THIS } // Update state here, on the main thread uiState = data } Example: User Profile Card Built something similar for a project. Simplified version:\n@Composable fun UserCard(user: User) { Card( modifier = Modifier .padding(16.dp) .fillMaxWidth() ) { Row( modifier = Modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically ) { // Avatar AsyncImage( model = user.avatarUrl, contentDescription = \u0026#34;Profile picture\u0026#34;, modifier = Modifier .size(50.dp) .clip(CircleShape) ) Spacer(Modifier.width(16.dp)) // User info Column { Text( text = user.name, style = MaterialTheme.typography.subtitle1 ) Text( text = user.email, style = MaterialTheme.typography.body2, color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f) ) } } } } Why Use Compose Main benefits:\nLess boilerplate - No findViewById, no view binding setup, no XML files. Everything in Kotlin.\nLive previews - Preview composables directly in Android Studio. Speeds up development.\nEasier to reuse - Composable functions are just functions. Reuse a component by calling the function. No custom views or include layouts needed.\nBetter state management - When state changes, only affected composables recompose. More efficient than invalidating entire view hierarchies.\nTips Break things down - If a composable is getting long, split into smaller functions. Try to keep under 50 lines.\nUse previews - The @Preview annotation helps. Use it to see UI without running the app.\nHoist state up - Keep state as high in hierarchy as possible. Only put it where needed.\nLearn LaunchedEffect - Handles side effects like API calls. Essential for real apps.\nFinal Thoughts Compose has a learning curve, especially coming from XML. Mental model is different - you\u0026rsquo;re describing UI, not building a view hierarchy. Once it clicks, you\u0026rsquo;ll build UIs faster.\nStart with a small feature, maybe a single screen. Don\u0026rsquo;t convert your entire app at once. Get comfortable with basics - composables, state, modifiers - then explore advanced topics like animations and custom layouts.\nCompose documentation is good. Community is helpful too.\nCheck out my other Android articles if you want to learn more.\n","permalink":"https://www.codefright.com/posts/jetpack-compose/","summary":"Been using XML for Android UIs for over a decade. When Jetpack Compose came out, I was very interested to learn this. After using it in production for a couple of years, I prefer it over XML for most cases.\nWhat is Jetpack Compose? Compose lets you build UIs using Kotlin functions instead of XML. You write functions that return UI instead of layout files. It\u0026rsquo;s declarative - you describe what you want, Compose handles the rendering.","title":"⚡ Let's Explore Jetpack Compose!"},{"content":"Built a lot of custom views over the years. Sometimes because Android doesn\u0026rsquo;t have what you need, sometimes because design team wants something specific. Made progress bars, custom buttons, animated indicators.\nCustom views can be intimidating at first. Lots to learn - measurement, layout, drawing, touch handling. Once you understand the basics, you can build almost anything.\nWhen Do You Need Custom Views? Standard Android widgets cover most cases, but sometimes you need something custom:\nUnique animations or visual effects Custom touch interactions Complex layouts that are hard to achieve with standard views Performance-critical UI that needs fine control Used custom views for circular progress indicators, custom sliders, animated backgrounds. Powerful when you need them.\nA Simple Example Basic example - a view that draws a circle and changes color when touched. Covers the fundamentals:\nclass ColorChangeCircleView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { private val paint = Paint(Paint.ANTI_ALIAS_FLAG) private var currentColor = Color.BLUE init { // Enable touch events isClickable = true } override fun onDraw(canvas: Canvas) { super.onDraw(canvas) // Get the center and radius val centerX = width / 2f val centerY = height / 2f val radius = min(width, height) / 3f // Draw the circle paint.color = currentColor canvas.drawCircle(centerX, centerY, radius, paint) } override fun onTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_DOWN -\u0026gt; { // Change color randomly currentColor = Color.rgb( Random.nextInt(256), Random.nextInt(256), Random.nextInt(256) ) invalidate() // Redraw the view return true } } return super.onTouchEvent(event) } } Measurement and Layout Understanding how views measure and layout themselves is crucial. How it works:\noverride fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { // Calculate the ideal size of the view based on content val desiredWidth = suggestedMinimumWidth + paddingLeft + paddingRight val desiredHeight = suggestedMinimumHeight + paddingTop + paddingBottom // Reconcile size with any constraints from the parent val finalWidth = resolveSize(desiredWidth, widthMeasureSpec) val finalHeight = resolveSize(desiredHeight, heightMeasureSpec) // Must call this to save the measurements setMeasuredDimension(finalWidth, finalHeight) } override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) { super.onSizeChanged(w, h, oldw, oldh) // Update size-dependent calculations circleRadius = min(w, h) / 3f // Update drawing bounds rect.set( paddingLeft.toFloat(), paddingTop.toFloat(), (w - paddingRight).toFloat(), (h - paddingBottom).toFloat() ) } State Management Always handle configuration changes and state restoration:\noverride fun onSaveInstanceState(): Parcelable { val superState = super.onSaveInstanceState() return Bundle().apply { putParcelable(\u0026#34;superState\u0026#34;, superState) putInt(\u0026#34;currentColor\u0026#34;, currentColor) } } override fun onRestoreInstanceState(state: Parcelable?) { val bundle = state as Bundle super.onRestoreInstanceState(bundle.getParcelable(\u0026#34;superState\u0026#34;)) currentColor = bundle.getInt(\u0026#34;currentColor\u0026#34;) invalidate() } Making It Configurable Let\u0026rsquo;s make our view configurable through XML with various attribute types:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;declare-styleable name=\u0026#34;ColorChangeCircleView\u0026#34;\u0026gt; \u0026lt;attr name=\u0026#34;circleRadius\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;defaultColor\u0026#34; format=\u0026#34;color\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;shapeStyle\u0026#34; format=\u0026#34;enum\u0026#34;\u0026gt; \u0026lt;enum name=\u0026#34;filled\u0026#34; value=\u0026#34;0\u0026#34; /\u0026gt; \u0026lt;enum name=\u0026#34;stroke\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/attr\u0026gt; \u0026lt;attr name=\u0026#34;strokeWidth\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;enableAnimation\u0026#34; format=\u0026#34;boolean\u0026#34; /\u0026gt; \u0026lt;/declare-styleable\u0026gt; \u0026lt;/resources\u0026gt; And the corresponding Kotlin implementation:\ninit { context.theme.obtainStyledAttributes( attrs, R.styleable.ColorChangeCircleView, 0, 0 ).apply { try { circleRadius = getDimension( R.styleable.ColorChangeCircleView_circleRadius, resources.getDimension(R.dimen.default_radius) ) defaultColor = getColor( R.styleable.ColorChangeCircleView_defaultColor, Color.BLUE ) shapeStyle = getInt( R.styleable.ColorChangeCircleView_shapeStyle, SHAPE_STYLE_FILLED ) strokeWidth = getDimension( R.styleable.ColorChangeCircleView_strokeWidth, resources.getDimension(R.dimen.default_stroke_width) ) enableAnimation = getBoolean( R.styleable.ColorChangeCircleView_enableAnimation, false ) } finally { recycle() } } currentColor = defaultColor } Advanced Touch Handling Implement sophisticated touch interactions using GestureDetector:\nclass ColorChangeCircleView : View { private val gestureDetector = GestureDetectorCompat(context, object : GestureDetector.SimpleOnGestureListener() { override fun onDown(e: MotionEvent): Boolean = true override fun onSingleTapUp(e: MotionEvent): Boolean { changeColor() return true } override fun onFling( e1: MotionEvent?, e2: MotionEvent, velocityX: Float, velocityY: Float ): Boolean { startSpinAnimation(velocityX) return true } }) override fun onTouchEvent(event: MotionEvent): Boolean { return gestureDetector.onTouchEvent(event) || super.onTouchEvent(event) } } Animation Integration Add smooth animations to your custom view:\nprivate fun startColorAnimation(newColor: Int) { ValueAnimator.ofArgb(currentColor, newColor).apply { duration = 300 interpolator = FastOutSlowInInterpolator() addUpdateListener { animator -\u0026gt; currentColor = animator.animatedValue as Int invalidate() } start() } } Accessibility Considerations Make your custom view accessible to all users:\ninit { // Set content description contentDescription = context.getString(R.string.color_circle_description) // Enable accessibility events importantForAccessibility = IMPORTANT_FOR_ACCESSIBILITY_YES } override fun onInitializeAccessibilityNodeInfo(info: AccessibilityNodeInfo) { super.onInitializeAccessibilityNodeInfo(info) info.className = Button::class.java.name info.isClickable = true info.addAction(AccessibilityNodeInfo.ACTION_CLICK) } Performance Tips Performance mistakes I made with custom views:\nDon\u0026rsquo;t create objects in onDraw()\nonDraw() gets called a lot. Creating objects there will cause garbage collection, which leads to jank:\n// This is bad - creates a new Paint every frame override fun onDraw(canvas: Canvas) { val paint = Paint() // Don\u0026#39;t do this! canvas.drawCircle(..., paint) } // Do this instead - create once, reuse private val paint = Paint() override fun onDraw(canvas: Canvas) { canvas.drawCircle(..., paint) } Use hardware acceleration\nEnable it in your manifest or activity. It makes drawing much faster:\n\u0026lt;activity android:hardwareAccelerated=\u0026#34;true\u0026#34; /\u0026gt; Invalidate efficiently\nOnly invalidate what changed. If only part of your view needs redrawing, use the version that takes coordinates:\n// Invalidate the whole view (slower) invalidate() // Invalidate just a region (faster) invalidate(left, top, right, bottom) // For thread safety postInvalidate() Debugging Custom Views Debugging custom views can be frustrating. Some tricks:\noverride fun onDraw(canvas: Canvas) { super.onDraw(canvas) if (BuildConfig.DEBUG) { paint.style = Paint.Style.STROKE paint.color = Color.RED canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint) } } Log measurements: override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { super.onMeasure(widthMeasureSpec, heightMeasureSpec) if (BuildConfig.DEBUG) { val widthMode = MeasureSpec.getMode(widthMeasureSpec) val widthSize = MeasureSpec.getSize(widthMeasureSpec) Log.d(TAG, \u0026#34;Width Mode: ${getModeString(widthMode)}, Size: $widthSize\u0026#34;) } } Testing Custom Views Here\u0026rsquo;s a basic test setup:\n@RunWith(AndroidJUnit4::class) class ColorChangeCircleViewTest { private lateinit var view: ColorChangeCircleView @Before fun setup() { view = ColorChangeCircleView( InstrumentationRegistry.getInstrumentation().targetContext ) } @Test fun testColorChange() { val initialColor = view.getCurrentColor() view.performClick() assertNotEquals(initialColor, view.getCurrentColor()) } } A Real-World Example: Custom Progress View Here\u0026rsquo;s a more practical example - a custom progress view that fills up like a battery:\nclass BatteryProgressView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { private var progress = 0f private val paint = Paint(Paint.ANTI_ALIAS_FLAG) private val rect = RectF() fun setProgress(value: Float) { progress = value.coerceIn(0f, 100f) invalidate() } override fun onDraw(canvas: Canvas) { super.onDraw(canvas) // Draw battery outline paint.style = Paint.Style.STROKE paint.color = Color.GRAY rect.set(0f, 0f, width.toFloat(), height.toFloat()) canvas.drawRect(rect, paint) // Draw battery level paint.style = Paint.Style.FILL paint.color = when { progress \u0026lt; 20f -\u0026gt; Color.RED progress \u0026lt; 50f -\u0026gt; Color.YELLOW else -\u0026gt; Color.GREEN } val levelWidth = (width * (progress / 100f)) rect.set(0f, 0f, levelWidth, height.toFloat()) canvas.drawRect(rect, paint) } } Resources for Further Learning Android Developer Documentation on Custom Views Android Graphics Architecture Material Design Guidelines Wrapping Up Custom views are powerful, but have a learning curve. Start simple - draw a shape, handle a touch event. Then gradually add complexity. Don\u0026rsquo;t try to build something complex on first try.\nKey is understanding the lifecycle: measurement, layout, and drawing. Once you get those, you can build almost anything.\nIf building a custom view and run into issues, Android documentation is helpful. Don\u0026rsquo;t forget about performance - profile your view to make sure it\u0026rsquo;s not causing jank.\nCheck out my other Android articles.\n","permalink":"https://www.codefright.com/posts/custom-views/","summary":"Built a lot of custom views over the years. Sometimes because Android doesn\u0026rsquo;t have what you need, sometimes because design team wants something specific. Made progress bars, custom buttons, animated indicators.\nCustom views can be intimidating at first. Lots to learn - measurement, layout, drawing, touch handling. Once you understand the basics, you can build almost anything.\nWhen Do You Need Custom Views? Standard Android widgets cover most cases, but sometimes you need something custom:","title":"⚡ Guide to Custom Views in Android"},{"content":"First used coroutines in 2019 on a project. Had callback hell - fetching user data, then posts, then comments, all nested three levels deep. Code was unreadable, debugging was difficult.\nDecided to try coroutines. Took a while to understand them. Once I got it, couldn\u0026rsquo;t go back. Been using them in production for years across multiple apps. Sharing what I learned.\nWhat Are Coroutines? Coroutines are lightweight threads that can pause and resume. They can suspend execution without blocking the thread. When you call a network API or read from a database, the coroutine pauses, lets other work happen, then resumes when data is ready.\nDuring that pause, the coroutine isn\u0026rsquo;t consuming CPU. Just waiting - for network response, file I/O, or delay to finish. Meanwhile your app can do other things. This keeps your UI responsive on Android.\nGetting Started Add the coroutines dependency. Using version 1.10.1 here, check for latest:\ndependencies { implementation \u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.10.1\u0026#34; } Your First Coroutine Simple example to get started:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // Launch a coroutine in the lifecycle scope lifecycleScope.launch { // This is suspended code delay(1000) // Wait for 1 second Log.d(\u0026#34;Coroutines\u0026#34;, \u0026#34;Hello from the future!\u0026#34;) } } } Dispatchers Dispatchers tell coroutines which thread pool to use. Main ones you\u0026rsquo;ll use:\nsuspend fun fetchUserData() { // For network calls, file I/O - this is what you\u0026#39;ll use most val userData = withContext(Dispatchers.IO) { apiService.getUser(userId) // Network call happens here } // For CPU-heavy stuff like sorting large lists, parsing complex JSON val processedData = withContext(Dispatchers.Default) { userData.process() // Heavy computation } // For UI updates - must be on Main thread withContext(Dispatchers.Main) { binding.textView.text = processedData.name } } Use Dispatchers.IO for network and database operations. Dispatchers.Default for CPU-intensive work. Dispatchers.Main for UI updates. Main dispatcher is default when launching from lifecycleScope.\nCoroutine Builders: launch vs async Two main ways to start coroutines:\n// Use launch when you don\u0026#39;t need a result back - \u0026#34;fire and forget\u0026#34; lifecycleScope.launch { saveUserPreferences() // Just do the work, don\u0026#39;t care about return value } // Use async when you need the result val userDeferred = lifecycleScope.async { fetchUserFromApi() // Returns User object } // Later, get the result val user = userDeferred.await() // You can also run multiple async operations in parallel val userDeferred = async { fetchUser() } val postsDeferred = async { fetchPosts() } val commentsDeferred = async { fetchComments() } // Wait for all of them val user = userDeferred.await() val posts = postsDeferred.await() val comments = commentsDeferred.await() Use async when you need to fetch multiple things in parallel. Much faster than sequential.\nScopes Coroutines live in scopes. When a scope is cancelled, all coroutines in it are cancelled too. This prevents memory leaks.\nMost common scopes:\n// In an Activity or Fragment lifecycleScope.launch { // This gets cancelled when the activity/fragment is destroyed fetchData() } // In a ViewModel class MyViewModel : ViewModel() { fun loadData() { viewModelScope.launch { // This gets cancelled when ViewModel is cleared fetchUserData() } } } Don\u0026rsquo;t use GlobalScope - it doesn\u0026rsquo;t get cancelled automatically, can lead to memory leaks. Always use lifecycleScope or viewModelScope.\nWhy Use Coroutines Main benefits:\nLightweight - A thread can take 1-2MB of memory. A coroutine? Just a few kilobytes. Can run thousands simultaneously.\nStructured concurrency - When you cancel a parent coroutine, all children get cancelled automatically. Makes cleanup easier. Example:\nviewModelScope.launch { try { val userInfo = async { fetchUserInfo() } val userPosts = async { fetchUserPosts() } // Wait for both results displayUserProfile(userInfo.await(), userPosts.await()) } catch (e: Exception) { // Handles errors from both operations! showError(\u0026#34;Oops, something went wrong!\u0026#34;) } } Sequential code that\u0026rsquo;s async - Write code that looks synchronous, but it\u0026rsquo;s actually asynchronous:\n// The callback nightmare I used to write fetchUserData { user -\u0026gt; fetchUserPosts(user.id) { posts -\u0026gt; fetchPostComments(posts[0].id) { comments -\u0026gt; // Three levels deep, hard to read, harder to debug displayComments(comments) } } } // With coroutines - clean and readable lifecycleScope.launch { val user = fetchUserData() val posts = fetchUserPosts(user.id) val comments = fetchPostComments(posts[0].id) displayComments(comments) } Reads like normal code, but each call can be async. No nesting, no callbacks. Clean, linear code.\nCommon Mistakes 1. Forgetting to cancel coroutines\nLaunched a coroutine that kept polling an API, forgot to cancel when user navigated away. Memory leak.\n2. Wrong dispatcher for network calls\nDid this once, app froze. Always use Dispatchers.IO for network calls:\n// This will freeze your UI - don\u0026#39;t do this! lifecycleScope.launch(Dispatchers.Main) { val data = api.fetchLargeData() // Blocks the main thread } // Do this instead lifecycleScope.launch { val data = withContext(Dispatchers.IO) { api.fetchLargeData() // Happens on background thread } // We\u0026#39;re back on Main thread here, safe to update UI showData(data) } 3. Using GlobalScope\nGlobalScope doesn\u0026rsquo;t get cancelled automatically, can cause memory leaks. Always prefer lifecycleScope or viewModelScope:\n// Bad - might outlive your activity GlobalScope.launch { fetchData() } // Good - automatically cancelled when activity is destroyed lifecycleScope.launch { fetchData() } 4. Touching UI from wrong thread\nThis will crash your app:\nlifecycleScope.launch(Dispatchers.IO) { val data = fetchData() // CRASH! Can\u0026#39;t update UI from IO thread binding.textView.text = data // This works - switch back to Main thread withContext(Dispatchers.Main) { binding.textView.text = data } } 5. Exceptions getting swallowed\nCoroutines can silently swallow exceptions. Always wrap risky operations in try-catch:\nlifecycleScope.launch { try { val data = fetchData() processData(data) } catch (e: Exception) { // Log it, show error to user, whatever Log.e(TAG, \u0026#34;Failed to fetch data\u0026#34;, e) showError(\u0026#34;Something went wrong\u0026#34;) } } Real Examples Loading Images Pattern for loading images from URLs:\nclass ImageLoader { fun loadImage(imageUrl: String, imageView: ImageView) { // Launch in the Main scope but switch to IO for network lifecycleScope.launch { try { val bitmap = withContext(Dispatchers.IO) { URL(imageUrl).openStream().use { BitmapFactory.decodeStream(it) } } // Back on Main thread imageView.setImageBitmap(bitmap) } catch (e: Exception) { // Handle error Log.e(\u0026#34;ImageLoader\u0026#34;, \u0026#34;Failed to load image\u0026#34;, e) } } } } Cache-First Data Fetching Pattern used in most apps. Try cache first, fall back to network:\nclass DataRepository { suspend fun fetchUserData(userId: String): User { // Try cache first return withContext(Dispatchers.IO) { try { val cachedUser = database.getUser(userId) if (cachedUser.isUpToDate()) { return@withContext cachedUser } // Cache miss or outdated, fetch from network val freshUser = api.fetchUser(userId) // Update cache in the background launch { database.saveUser(freshUser) } freshUser } catch (e: Exception) { // If everything fails, at least try to return cached data database.getUser(userId) ?: throw e } } } } Wrapping Up Coroutines have a learning curve. Once they click, they become second nature. Been using them for years, can\u0026rsquo;t imagine going back to callbacks or RxJava for simple async operations.\nStart simple - use lifecycleScope.launch for basic async work, then explore async, withContext, and advanced patterns. Don\u0026rsquo;t try to learn everything at once.\nCheck out my other articles on Android development.\n","permalink":"https://www.codefright.com/posts/kotlin-coroutines/","summary":"First used coroutines in 2019 on a project. Had callback hell - fetching user data, then posts, then comments, all nested three levels deep. Code was unreadable, debugging was difficult.\nDecided to try coroutines. Took a while to understand them. Once I got it, couldn\u0026rsquo;t go back. Been using them in production for years across multiple apps. Sharing what I learned.\nWhat Are Coroutines? Coroutines are lightweight threads that can pause and resume.","title":"⚡ Kotlin Coroutines for the Beginners"},{"content":"Anu S Pillai Android | Kotlin | Flutter\n✉️ anu_icloud@icloud.com | 📍 Bangalore, India\nSummary Experienced Android and Kotlin developer with over 12 years of expertise designing, architecting and developing Android applications, SDKs and library projects. Extensive experience leading teams and delivering high-quality software solutions.\nSuccessfully developed and published over 25 apps on PlayStore, including apps with over 100K downloads, such as South Indian Bank mPassbook, Scootsy (acquired by Swiggy), Revofit (a fitness/lifestyle app backed by Marico), Wellthy Care (a chronic disease management platform, acquired by TruDoc Inc.), and Catch \u0026amp; Win - Howzzattt (a 2D game developed using AndEngine for Toonz Animation India).\nPassionate about learning and mastering new technologies and frameworks independently. Enjoys sharing knowledge through meetups, blogging, and open-source contributions. Would love to explore more of KMM and mobile LLMs.\nExperience Tech Lead - Apps and Frameworks Borqs Software Solutions, Bangalore (2023 - Present)\nLeading a team working on an array of inhouse as well as ODC projects involving Android, Kotlin, Flutter Worked as an Android / Kotlin Tech Consultant for an AAOS - Kotlin project for Qualcomm Inc. Lead a team designing and architecting a Kotlin MQTT Cloud Sync module + Flutter companion app for an overseas Android Automotive project Currently working with Meta Inc. (Facebook) for developing a Flutter based cross-platform desktop project Actively participate in code reviews and project architecture discussions. Conduct internal meetups to upskill and mentor developers Lead Software Developer - Android Wellthy Therapeutics, Bangalore (2021 - 2023)\nArchitected and developed Wellthy app and SDK for Android platform with 100K+ downloads and maintaining \u0026gt;99% weekly crash free users Lead developer responsible for architecting and developing new feature requirements Worked on Improving app user experience and timely bug fixes which resulted in PlayStore rating going up from 3.5 to 4.6 in a year Collaborated with cross-functional teams to design and develop features that met business requirements Led the team to brainstorm and implement code optimizations and features which led to a significant improvement in code reusability, modularity and maintainability Helped the organization to achieve faster development goals by introducing code templates and generators Overlooking the Sprint plans, Task prioritization and ensure timely sprint / task closure Maintaining the team\u0026rsquo;s performance scorecards, BvA analysis, setting and tracking quarterly goals Lead the Wellthy SDK development team to develop and document SDK based on Wellthy Platform Senior Software Developer - Android Wellthy Therapeutics, Bangalore (2017 - 2021)\nArchitected and developed Wellthy app for Android platform Developed and maintained mobile applications using Kotlin language Bug tracking / Fixing and timely release and team management Write and review test cases Senior Application Developer Scootsy (Acquired by Swiggy), Mumbai (2014 - 2017)\nLed the team developing Android Apps like Scootsy, Revofit, Scootsy VMS from scratch Developed and maintained mobile applications using Java Collaborated with cross-functional teams to design and develop mobile applications Developer responsible for coordinating the project. Followed Agile / Scrum development methodology Junior Android Developer Simrge, Trivandrum (2013 - 2014)\nDeveloped Android Apps like mParking Dubai, Howzzattt 2D Game using AndEngine, SIB mPassbook (Android + Blackberry), iCRM for vTiger First Android Hire. Followed Agile development Education Bachelor of Information Technology Anna University, Chennai (2008 - 2012)\nSkills Languages Kotlin (Proficient) Java (Proficient) Flutter / Dart (Advanced) KMM (Beginner) Python (Intermediate) Links Stack Overflow LinkedIn GitHub Twitter Blog Notable Contributions WELLTHY CARE (WELLTHY THERAPEUTICS) View on Play Store\nWellthy Care is the digital health coach that will help you manage diabetes, chronic kidney disease (CKD) and other such chronic conditions.\nTechnologies used: Kotlin, MVVM, Hilt, Coroutines, Retrofit with RxJava for API calls, Realm, Espresso, JUnit, AWS Mqtt SCOOTSY (ACQUIRED BY SWIGGY) View on Play Store\nScootsy is an intra-city delivery service in Mumbai that delivers from the best restaurants, food stores, book shops, toy stores, fashion outlets, gift shops, sport stores and more.\nTechnologies used: Java, SQLite, Retrofit, Socket.IO, Firebase, GraphQL SOUTH INDIAN BANK M-PASSBOOK (ANDROID / WINDOWS /BLACKBERRY) View Details\nIndia\u0026rsquo;s one of the first mobile passbook app. Track your SIB account transactions on the go. Developed for South Indian Bank. Developed for Android and Windows. Ported to Blackberry.\nTechnologies used: Java, SQLite, Retrofit, C# (for Windows app) And Many More!\n","permalink":"https://www.codefright.com/resume/","summary":"Anu S Pillai Android | Kotlin | Flutter\n✉️ anu_icloud@icloud.com | 📍 Bangalore, India\nSummary Experienced Android and Kotlin developer with over 12 years of expertise designing, architecting and developing Android applications, SDKs and library projects. Extensive experience leading teams and delivering high-quality software solutions.\nSuccessfully developed and published over 25 apps on PlayStore, including apps with over 100K downloads, such as South Indian Bank mPassbook, Scootsy (acquired by Swiggy), Revofit (a fitness/lifestyle app backed by Marico), Wellthy Care (a chronic disease management platform, acquired by TruDoc Inc.","title":""},{"content":"FlipTimerView A customizable flip animation timer library for Android, developed in Kotlin.\nSimple flip animation with customizable duration Support for days, hours, minutes and seconds http_cyclic_mocks A lightweight Dart library for mocking HTTP responses with Dio. Mock Multiple Responses for single route / endpoint.\nSupport for multiple responses per endpoint Cyclic response patterns Easy integration with existing Dio setup Perfect for testing and development KinderScript [Work in Progress] A simple terminal based child-friendly programming language for learning coding basics. Developed completely in Kotlin.\nSimple syntax for kids Built for educational purposes ","permalink":"https://www.codefright.com/projects/","summary":"FlipTimerView A customizable flip animation timer library for Android, developed in Kotlin.\nSimple flip animation with customizable duration Support for days, hours, minutes and seconds http_cyclic_mocks A lightweight Dart library for mocking HTTP responses with Dio. Mock Multiple Responses for single route / endpoint.\nSupport for multiple responses per endpoint Cyclic response patterns Easy integration with existing Dio setup Perfect for testing and development KinderScript [Work in Progress] A simple terminal based child-friendly programming language for learning coding basics.","title":"Projects"}]