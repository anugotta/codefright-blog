[{"content":"Let\u0026rsquo;s explore how to build your first Kotlin Multiplatform Mobile (KMM) app!\nWhat is Kotlin Multiplatform Mobile? Think of KMM is like a code-sharing wand that lets you write business logic once in Kotlin and use it on both iOS and Android. It\u0026rsquo;s like having a universal translator for your code - write once, run everywhere (well, on mobile at least)!\nWhen you use KMM, you get to:\nShare business logic across platforms Keep native UI for the best user experience Reduce duplicate code and potential bugs Speed up development time Setting Up Your Environment First, let\u0026rsquo;s get your development environment ready. You\u0026rsquo;ll need:\n// Root build.gradle buildscript { repositories { google() mavenCentral() } dependencies { classpath(\u0026#34;org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.20\u0026#34;) classpath(\u0026#34;com.android.tools.build:gradle:8.1.0\u0026#34;) } } Your project structure should look like this:\nMyKMMProject/ ├── androidApp/ ├── iosApp/ └── shared/ ├── src/ ├── commonMain/ ├── androidMain/ └── iosMain/ Your First Shared Code Let\u0026rsquo;s start with something simple - a shared data model:\n// commonMain/kotlin/com/example/User.kt data class User( val id: String, val name: String, val email: String ) Now, let\u0026rsquo;s add some platform-specific code:\n// commonMain/kotlin/com/example/Platform.kt expect class Platform() { val platform: String } // androidMain/kotlin/com/example/Platform.kt actual class Platform actual constructor() { actual val platform: String = \u0026#34;Android ${android.os.Build.VERSION.SDK_INT}\u0026#34; } // iosMain/kotlin/com/example/Platform.kt actual class Platform actual constructor() { actual val platform: String = UIDevice.currentDevice.systemName() } Networking Made Easy Here\u0026rsquo;s how to set up a shared network layer using Ktor:\nclass ApiClient { private val httpClient = HttpClient { install(ContentNegotiation) { json() } } suspend fun fetchUser(id: String): User { return httpClient.get(\u0026#34;https://api.example.com/users/$id\u0026#34;).body() } } Platform-Specific UI Android UI class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { UserProfile() } } } @Composable fun UserProfile() { var user by remember { mutableStateOf\u0026lt;User?\u0026gt;(null) } LaunchedEffect(Unit) { user = ApiClient().fetchUser(\u0026#34;123\u0026#34;) } Column { Text(user?.name ?: \u0026#34;Loading...\u0026#34;) Text(user?.email ?: \u0026#34;\u0026#34;) } } iOS UI struct ContentView: View { @State private var user: User? = nil var body: some View { VStack { Text(user?.name ?? \u0026#34;Loading...\u0026#34;) Text(user?.email ?? \u0026#34;\u0026#34;) } .onAppear { ApiClient().fetchUser(id: \u0026#34;123\u0026#34;) { fetchedUser in user = fetchedUser } } } } Common Pitfalls to Watch Out For The Threading Trap: Remember that each platform handles threading differently. Use Dispatchers.Default for shared code: class UserRepository { suspend fun getUser(id: String) = withContext(Dispatchers.Default) { // Safe to call from any platform api.fetchUser(id) } } The Memory Maze: iOS and Android handle memory differently. Use weak references when needed: // In shared code class SharedViewModel { private val _state = MutableStateFlow\u0026lt;User?\u0026gt;(null) val state = _state.asStateFlow() } The Platform Puzzle: Don\u0026rsquo;t access platform-specific APIs in common code: // DON\u0026#39;T do this in commonMain fun getPlatformVersion() = Build.VERSION.SDK_INT // Won\u0026#39;t work! // DO this instead expect fun getPlatformVersion(): String actual fun getPlatformVersion() = Build.VERSION.SDK_INT.toString() Real-World Example: Image Loading Here\u0026rsquo;s a practical example of an image loader that works across platforms:\ninterface ImageLoader { suspend fun loadImage(url: String): ImageBitmap } class AndroidImageLoader : ImageLoader { override suspend fun loadImage(url: String): ImageBitmap = withContext(Dispatchers.IO) { URL(url).openStream().use { BitmapFactory.decodeStream(it).asImageBitmap() } } } class IosImageLoader : ImageLoader { override suspend fun loadImage(url: String): ImageBitmap = withContext(Dispatchers.Default) { NSUrl(string = url)?.let { nsUrl -\u0026gt; NSData.dataWithContentsOfURL(nsUrl)?.toUIImage()?.toImageBitmap() } ?: throw IllegalArgumentException(\u0026#34;Invalid URL\u0026#34;) } } Testing Your KMM Code Here\u0026rsquo;s how to test your shared code:\nclass UserRepositoryTest { @Test fun testFetchUser() = runTest { val repository = UserRepository(mockApi) val user = repository.getUser(\u0026#34;123\u0026#34;) assertEquals(\u0026#34;John Doe\u0026#34;, user.name) } } Conclusion KMM can easily help you reduce your cross-platform app development time and effort by a lot!\nAlso don\u0026rsquo;t forget to check out the official KMM documentation for more advanced topics.\n","permalink":"https://www.codefright.com/posts/kmm-guide/","summary":"Let\u0026rsquo;s explore how to build your first Kotlin Multiplatform Mobile (KMM) app!\nWhat is Kotlin Multiplatform Mobile? Think of KMM is like a code-sharing wand that lets you write business logic once in Kotlin and use it on both iOS and Android. It\u0026rsquo;s like having a universal translator for your code - write once, run everywhere (well, on mobile at least)!\nWhen you use KMM, you get to:\nShare business logic across platforms Keep native UI for the best user experience Reduce duplicate code and potential bugs Speed up development time Setting Up Your Environment First, let\u0026rsquo;s get your development environment ready.","title":"⚡ Getting Started with Kotlin Multiplatform Mobile"},{"content":"This guide is also available as a comprehensive GitHub repository:\nCore Android Concepts Activities \u0026amp; Fragments Activity Lifecycle onCreate(): Activity is first created\nInitialize UI Set content view Initialize variables onStart(): Activity becomes visible\nPrepare UI elements Register broadcast receivers onResume(): Activity starts interacting with user\nStart animations/video playback Initialize foreground services onPause(): Activity partially visible but not focused\nPause ongoing operations Save draft data onStop(): Activity no longer visible\nSave persistent data Release resources onDestroy(): Activity being destroyed\nCleanup resources Unregister receivers Common Flows:\nNormal Flow: onCreate → onStart → onResume → onPause → onStop → onDestroy Background Flow: onStop → onRestart → onStart Configuration Change: onPause → onSaveInstanceState → onStop → onDestroy → onCreate → onStart → onRestoreInstanceState → onResume Fragment Lifecycle Complete Flow: onAttach → onCreate → onCreateView → onViewCreated → onActivityCreated → onStart → onResume → onPause → onStop → onDestroyView → onDestroy → onDetach Key Methods:\nonAttach(): Fragment attached to activity onCreateView(): Create and return view hierarchy onViewCreated(): View setup after creation onDestroyView(): View hierarchy being destroyed Services Types of Services Foreground Service class MusicService : Service() { override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { val notification = createNotification() startForeground(NOTIFICATION_ID, notification) return START_STICKY } } Background Service class DataSyncService : Service() { override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { // Perform background operation return START_NOT_STICKY } } Bound Service class LocalService : Service() { private val binder = LocalBinder() inner class LocalBinder : Binder() { fun getService(): LocalService = this@LocalService } override fun onBind(intent: Intent): IBinder = binder } IntentService (Deprecated, use WorkManager instead) class DataProcessingService : IntentService(\u0026#34;DataProcessingService\u0026#34;) { override fun onHandleIntent(intent: Intent?) { // Process data in background } } Intents \u0026amp; Communication Types of Intents Explicit Intents // Start specific activity val intent = Intent(context, TargetActivity::class.java) intent.putExtra(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) startActivity(intent) Implicit Intents // Open URL val intent = Intent(Intent.ACTION_VIEW, Uri.parse(\u0026#34;https://example.com\u0026#34;)) startActivity(intent) // Share text val shareIntent = Intent().apply { action = Intent.ACTION_SEND type = \u0026#34;text/plain\u0026#34; putExtra(Intent.EXTRA_TEXT, \u0026#34;Share this\u0026#34;) } startActivity(Intent.createChooser(shareIntent, \u0026#34;Share via\u0026#34;)) Broadcast Receivers Static Receiver (Manifest-declared) \u0026lt;receiver android:name=\u0026#34;.MyReceiver\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.BOOT_COMPLETED\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; Dynamic Receiver (Runtime registration) private val receiver = object : BroadcastReceiver() { override fun onReceive(context: Context, intent: Intent) { // Handle broadcast } } override fun onResume() { super.onResume() registerReceiver(receiver, IntentFilter(\u0026#34;ACTION_NAME\u0026#34;)) } override fun onPause() { super.onPause() unregisterReceiver(receiver) } Kotlin Fundamentals Key Features Null Safety // Nullable types var nullableString: String? = null // Safe call operator nullableString?.length // Elvis operator val length = nullableString?.length ?: 0 // Not-null assertion val definiteLength = nullableString!!.length // Throws if null Properties // Lazy initialization val expensive: String by lazy { // Computed only on first access computeExpensiveString() } // Late initialization lateinit var lateinitVar: String // Initialize later lateinitVar = \u0026#34;Now initialized\u0026#34; // Custom getters/setters var counter = 0 get() = field set(value) { if (value \u0026gt;= 0) field = value } Modern Android Development Jetpack Compose Basic Composables @Composable fun Greeting(name: String) { Column { Text(text = \u0026#34;Hello $name!\u0026#34;) Button(onClick = { /* action */ }) { Text(\u0026#34;Click me\u0026#34;) } } } State Management // Local state @Composable fun Counter() { var count by remember { mutableStateOf(0) } Button(onClick = { count++ }) { Text(\u0026#34;Count: $count\u0026#34;) } } // Hoisted state @Composable fun StatefulCounter( count: Int, onCountChange: (Int) -\u0026gt; Unit ) { Button(onClick = { onCountChange(count + 1) }) { Text(\u0026#34;Count: $count\u0026#34;) } } Side Effects @Composable fun MyScreen() { // Run on first composition LaunchedEffect(Unit) { // Launch coroutine } // Run on every successful composition SideEffect { // Update non-compose code } // Cleanup when leaving composition DisposableEffect(Unit) { onDispose { // Cleanup } } } Navigation Component Navigation Graph \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;navigation xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; android:id=\u0026#34;@+id/nav_graph\u0026#34; app:startDestination=\u0026#34;@id/homeFragment\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/homeFragment\u0026#34; android:name=\u0026#34;.HomeFragment\u0026#34;\u0026gt; \u0026lt;action android:id=\u0026#34;@+id/to_detail\u0026#34; app:destination=\u0026#34;@id/detailFragment\u0026#34;\u0026gt; \u0026lt;argument android:name=\u0026#34;itemId\u0026#34; app:argType=\u0026#34;string\u0026#34; /\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/fragment\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/detailFragment\u0026#34; android:name=\u0026#34;.DetailFragment\u0026#34; /\u0026gt; \u0026lt;/navigation\u0026gt; Navigation in Code // Using Safe Args class HomeFragment : Fragment() { private val navArgs: HomeFragmentArgs by navArgs() fun navigate() { val action = HomeFragmentDirections.toDetail(itemId = \u0026#34;123\u0026#34;) findNavController().navigate(action) } } Architecture Components MVVM Pattern // Model data class User(val id: String, val name: String) // ViewModel class UserViewModel : ViewModel() { private val _user = MutableLiveData\u0026lt;User\u0026gt;() val user: LiveData\u0026lt;User\u0026gt; = _user fun loadUser(id: String) { viewModelScope.launch { _user.value = repository.getUser(id) } } } // View class UserFragment : Fragment() { private val viewModel: UserViewModel by viewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewModel.user.observe(viewLifecycleOwner) { user -\u0026gt; // Update UI } } } State Management StateFlow class UserViewModel : ViewModel() { private val _uiState = MutableStateFlow\u0026lt;UiState\u0026gt;(UiState.Initial) val uiState: StateFlow\u0026lt;UiState\u0026gt; = _uiState.asStateFlow() fun loadData() { viewModelScope.launch { _uiState.value = UiState.Loading try { val result = repository.getData() _uiState.value = UiState.Success(result) } catch (e: Exception) { _uiState.value = UiState.Error(e.message) } } } } // States sealed class UiState { object Initial : UiState() object Loading : UiState() data class Success(val data: Data) : UiState() data class Error(val message: String?) : UiState() } Room Database // Entity @Entity(tableName = \u0026#34;users\u0026#34;) data class UserEntity( @PrimaryKey val id: String, val name: String, val email: String ) // DAO @Dao interface UserDao { @Query(\u0026#34;SELECT * FROM users\u0026#34;) fun getAll(): Flow\u0026lt;List\u0026lt;UserEntity\u0026gt;\u0026gt; @Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(user: UserEntity) @Delete suspend fun delete(user: UserEntity) } // Database @Database(entities = [UserEntity::class], version = 1) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao } Dependency Injection with Hilt // Application class @HiltAndroidApp class MyApplication : Application() // Module @Module @InstallIn(SingletonComponent::class) object AppModule { @Provides @Singleton fun provideDatabase(@ApplicationContext context: Context): AppDatabase { return Room.databaseBuilder( context, AppDatabase::class.java, \u0026#34;app_database\u0026#34; ).build() } } // ViewModel injection @HiltViewModel class MainViewModel @Inject constructor( private val repository: Repository ) : ViewModel() // Activity injection @AndroidEntryPoint class MainActivity : AppCompatActivity() Background Processing Coroutines class MainViewModel : ViewModel() { // Different Coroutine Scopes init { // ViewModel Scope viewModelScope.launch { // Runs on Main dispatcher by default } // Background work with IO dispatcher viewModelScope.launch(Dispatchers.IO) { // Network or database operations } // CPU-intensive work viewModelScope.launch(Dispatchers.Default) { // Complex calculations } } // Parallel Execution suspend fun loadDataInParallel() { coroutineScope { val result1 = async { api.getData1() } val result2 = async { api.getData2() } val combinedResult = result1.await() + result2.await() } } } WorkManager // Define Work class DataSyncWorker( context: Context, params: WorkerParameters ) : CoroutineWorker(context, params) { override suspend fun doWork(): Result { return try { // Do background work Result.success() } catch (e: Exception) { Result.retry() } } } // Schedule Work class Repository { fun scheduleSync() { val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .setRequiresBatteryNotLow(true) .build() val syncWork = OneTimeWorkRequestBuilder\u0026lt;DataSyncWorker\u0026gt;() .setConstraints(constraints) .setBackoffCriteria(BackoffPolicy.LINEAR, 10, TimeUnit.MINUTES) .build() WorkManager.getInstance(context) .enqueueUniqueWork( \u0026#34;sync_work\u0026#34;, ExistingWorkPolicy.REPLACE, syncWork ) } } RxJava // Basic Observable Observable.just(1, 2, 3, 4, 5) .map { it * 2 } .filter { it \u0026gt; 5 } .subscribe { println(it) } // Network Call with RxJava interface ApiService { @GET(\u0026#34;users\u0026#34;) fun getUsers(): Single\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; } class Repository { fun getUsers(): Single\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; { return apiService.getUsers() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) } } Data Management Secure Data Storage // Encrypted Shared Preferences val masterKey = MasterKey.Builder(context) .setKeyScheme(MasterKey.KeyScheme.AES256_GCM) .build() val sharedPreferences = EncryptedSharedPreferences.create( context, \u0026#34;secret_prefs\u0026#34;, masterKey, EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV, EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM ) // Encrypted Files val encryptedFile = EncryptedFile.Builder( context, File(context.filesDir, \u0026#34;secret.txt\u0026#34;), masterKey, EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB ).build() Network Security // Certificate Pinning with OkHttp val certificatePinner = CertificatePinner.Builder() .add(\u0026#34;example.com\u0026#34;, \u0026#34;sha256/XXXX=\u0026#34;) .build() val okHttpClient = OkHttpClient.Builder() .certificatePinner(certificatePinner) .build() // Retrofit with Security val retrofit = Retrofit.Builder() .baseUrl(\u0026#34;https://api.example.com/\u0026#34;) .client(okHttpClient) .addConverterFactory(GsonConverterFactory.create()) .build() Testing Unit Testing @Test fun `test user validation`() { val validator = UserValidator() assertTrue(validator.isValidEmail(\u0026#34;test@example.com\u0026#34;)) assertFalse(validator.isValidEmail(\u0026#34;invalid-email\u0026#34;)) } // ViewModel Testing @Test fun `test loading state`() = runTest { val repository = mockk\u0026lt;Repository\u0026gt;() coEvery { repository.getData() } returns Result.success(data) val viewModel = MainViewModel(repository) viewModel.loadData() assertEquals(UiState.Success(data), viewModel.uiState.value) } UI Testing with Espresso @Test fun testLoginFlow() { // Launch activity ActivityScenario.launch(LoginActivity::class.java) // Type text onView(withId(R.id.emailInput)) .perform(typeText(\u0026#34;test@example.com\u0026#34;)) // Click button onView(withId(R.id.loginButton)) .perform(click()) // Verify text onView(withId(R.id.statusText)) .check(matches(withText(\u0026#34;Success\u0026#34;))) } Compose UI Testing @Test fun testCounter() { composeTestRule.setContent { Counter() } composeTestRule .onNodeWithText(\u0026#34;Count: 0\u0026#34;) .assertExists() .performClick() composeTestRule .onNodeWithText(\u0026#34;Count: 1\u0026#34;) .assertExists() } Performance Optimization Memory Management class MainActivity : AppCompatActivity() { // Avoid memory leaks with weak references private val weakReference = WeakReference(this) // Proper bitmap handling private fun loadBitmap() { val options = BitmapFactory.Options().apply { inJustDecodeBounds = true } BitmapFactory.decodeResource(resources, R.drawable.image, options) options.apply { inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight) inJustDecodeBounds = false } } } // Memory Cache class ImageCache { private val memoryCache = object : LruCache\u0026lt;String, Bitmap\u0026gt;( (Runtime.getRuntime().maxMemory() / 1024).toInt() / 8 ) { override fun sizeOf(key: String, bitmap: Bitmap): Int { return bitmap.byteCount / 1024 } } } Build \u0026amp; Deployment Gradle Configuration // App level build.gradle.kts plugins { id(\u0026#34;com.android.application\u0026#34;) id(\u0026#34;kotlin-android\u0026#34;) id(\u0026#34;kotlin-kapt\u0026#34;) id(\u0026#34;dagger.hilt.android.plugin\u0026#34;) } android { defaultConfig { applicationId = \u0026#34;com.example.app\u0026#34; minSdk = 24 targetSdk = 34 versionCode = 1 versionName = \u0026#34;1.0.0\u0026#34; } buildTypes { release { isMinifyEnabled = true proguardFiles(getDefaultProguardFile(\u0026#34;proguard-android.txt\u0026#34;), \u0026#34;proguard-rules.pro\u0026#34;) } debug { applicationIdSuffix = \u0026#34;.debug\u0026#34; isDebuggable = true } } buildFeatures { compose = true viewBinding = true } } APK vs App Bundle // App Bundle benefits: // 1. Smaller download size // 2. Dynamic feature delivery // 3. Optimized for different devices // Configure dynamic feature android { dynamicFeatures = mutableSetOf(\u0026#34;:feature_module\u0026#34;) } // Install dynamic feature class MainActivity : AppCompatActivity() { private fun installFeature() { val request = SplitInstallRequest.newBuilder() .addModule(\u0026#34;feature_module\u0026#34;) .build() splitInstallManager.startInstall(request) .addOnSuccessListener { /* Handle success */ } .addOnFailureListener { /* Handle failure */ } } } CI/CD Pipeline # Example GitHub Actions workflow name: Android CI on: push: branches: [ main ] pull_request: branches: [ main ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up JDK uses: actions/setup-java@v2 with: java-version: \u0026#39;11\u0026#39; - name: Run Tests run: ./gradlew test - name: Build Debug APK run: ./gradlew assembleDebug - name: Upload APK uses: actions/upload-artifact@v2 with: name: app-debug path: app/build/outputs/apk/debug/app-debug.apk Data Structures \u0026amp; Algorithms Common Interview Problems 1. String Manipulation // Reverse String fun reverseString(str: String): String { return str.reversed() // Or manual implementation: return str.toCharArray() .apply { reverse() } .joinToString(\u0026#34;\u0026#34;) } // Check Palindrome fun isPalindrome(str: String): Boolean { val cleanStr = str.lowercase().filter { it.isLetterOrDigit() } return cleanStr == cleanStr.reversed() } 2. Array Operations // Find Missing Number fun findMissingNumber(arr: IntArray): Int { val n = arr.size + 1 val expectedSum = (n * (n + 1)) / 2 val actualSum = arr.sum() return expectedSum - actualSum } // Maximum Subarray Sum fun maxSubArraySum(arr: IntArray): Int { var maxSoFar = arr[0] var maxEndingHere = arr[0] for (i in 1 until arr.size) { maxEndingHere = maxOf(arr[i], maxEndingHere + arr[i]) maxSoFar = maxOf(maxSoFar, maxEndingHere) } return maxSoFar } 3. Linked List Operations data class ListNode( var value: Int, var next: ListNode? = null ) // Reverse Linked List fun reverseList(head: ListNode?): ListNode? { var prev: ListNode? = null var current = head while (current != null) { val next = current.next current.next = prev prev = current current = next } return prev } // Detect Cycle fun hasCycle(head: ListNode?): Boolean { var slow = head var fast = head while (fast?.next != null) { slow = slow?.next fast = fast.next?.next if (slow == fast) return true } return false } Android-Specific Optimizations 1. View Hierarchy Optimization // Flatten view hierarchy \u0026lt;merge xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!-- Child views --\u0026gt; \u0026lt;/merge\u0026gt; // Use ConstraintLayout for complex layouts \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;!-- Constraints reduce nesting --\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 2. RecyclerView Optimization class OptimizedAdapter : RecyclerView.Adapter\u0026lt;ViewHolder\u0026gt;() { // Implement DiffUtil private val diffCallback = object : DiffUtil.ItemCallback\u0026lt;Item\u0026gt;() { override fun areItemsTheSame(oldItem: Item, newItem: Item): Boolean { return oldItem.id == newItem.id } override fun areContentsTheSame(oldItem: Item, newItem: Item): Boolean { return oldItem == newItem } } // Use ListAdapter for automatic diff class EfficientAdapter : ListAdapter\u0026lt;Item, ViewHolder\u0026gt;(diffCallback) // View pool for shared ViewHolders init { setHasStableIds(true) recyclerView.setRecycledViewPool(viewPool) } } Best Practices \u0026amp; Tips Code Quality // Use meaningful names fun processUserData() instead of fun process() // Single Responsibility Principle class UserRepository { fun getUser() // Only user-related operations } // Dependency Injection over direct instantiation class MyViewModel @Inject constructor( private val repository: Repository ) // Error Handling sealed class Result\u0026lt;out T\u0026gt; { data class Success\u0026lt;T\u0026gt;(val data: T) : Result\u0026lt;T\u0026gt;() data class Error(val exception: Exception) : Result\u0026lt;Nothing\u0026gt;() } Security Best Practices // Secure data storage private fun storeSecurely(data: String) { val encryptedData = encrypt(data) securePreferences.edit().putString(\u0026#34;key\u0026#34;, encryptedData).apply() } // Network security private fun configureNetworkSecurity() { // Force HTTPS android:usesCleartextTraffic=\u0026#34;false\u0026#34; // Certificate pinning val certificatePinner = CertificatePinner.Builder() .add(\u0026#34;example.com\u0026#34;, \u0026#34;sha256/XXXX=\u0026#34;) .build() } Performance Tips // Lazy loading private val expensiveObject by lazy { // Created only when first accessed ExpensiveObject() } // Efficient image loading private fun loadImageEfficiently() { Glide.with(context) .load(imageUrl) .transition(DrawableTransitionOptions.withCrossFade()) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(imageView) } Additional Resources Keep up with Android Developers Blog Follow Android Dev Summit Practice with Android Code Labs Read official Material Design Guidelines Join Android development communities on Reddit and Stack Overflow ","permalink":"https://www.codefright.com/posts/interview-guide/","summary":"This guide is also available as a comprehensive GitHub repository:\nCore Android Concepts Activities \u0026amp; Fragments Activity Lifecycle onCreate(): Activity is first created\nInitialize UI Set content view Initialize variables onStart(): Activity becomes visible\nPrepare UI elements Register broadcast receivers onResume(): Activity starts interacting with user\nStart animations/video playback Initialize foreground services onPause(): Activity partially visible but not focused\nPause ongoing operations Save draft data onStop(): Activity no longer visible","title":"⚡ Android Developer Interview Guide"},{"content":"Hey! Let\u0026rsquo;s explore Jetpack Compose and see how it makes Android UI development more enjoyable.\nWhat is Jetpack Compose? Compose is just a different way to build your app\u0026rsquo;s UI. Instead of writing XML layouts and then manipulating them with code, you write Kotlin functions that describe your UI. It\u0026rsquo;s that simple.\nGetting Started First, add these to your build.gradle:\ndependencies { implementation \u0026#34;androidx.compose.ui:ui:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.material:material:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.ui:ui-tooling-preview:1.5.4\u0026#34; } Your First Composable Let\u0026rsquo;s write something simple:\n@Composable fun WelcomeText(name: String) { Text(\u0026#34;Hey $name, welcome to Compose!\u0026#34;) } That\u0026rsquo;s it! The @Composable annotation tells Compose that this function outputs UI elements. You can use it like any regular Kotlin function.\nState: Making Things Interactive State in Compose is just data that can change over time. When it changes, Compose updates your UI automatically:\n@Composable fun Counter() { var count by remember { mutableStateOf(0) } Column(modifier = Modifier.padding(16.dp)) { Text(\u0026#34;You clicked $count times\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Click me\u0026#34;) } } } Modifiers: Styling Your UI Modifiers are like CSS for your composables. They let you change how things look and behave:\n@Composable fun StyledButton( text: String, onClick: () -\u0026gt; Unit ) { Button( onClick = onClick, modifier = Modifier .padding(16.dp) .fillMaxWidth() .height(48.dp) ) { Text(text) } } Common Gotchas to Watch Out For State Reset: Don\u0026rsquo;t declare state outside composable functions: // DON\u0026#39;T do this var count = mutableStateOf(0) // Will reset on recomposition // DO this instead var count by remember { mutableStateOf(0) } Wrong Thread: UI updates must happen on the main thread: // DON\u0026#39;T do this LaunchedEffect(key1 = true) { withContext(Dispatchers.IO) { // UI updates here will crash } } // DO this instead LaunchedEffect(key1 = true) { val data = withContext(Dispatchers.IO) { // Do background work } // Update UI on main thread } Real World Example: A User Card Here\u0026rsquo;s how you might build a user profile card:\n@Composable fun UserCard(user: User) { Card( modifier = Modifier .padding(16.dp) .fillMaxWidth() ) { Row( modifier = Modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically ) { // Avatar AsyncImage( model = user.avatarUrl, contentDescription = \u0026#34;Profile picture\u0026#34;, modifier = Modifier .size(50.dp) .clip(CircleShape) ) Spacer(Modifier.width(16.dp)) // User info Column { Text( text = user.name, style = MaterialTheme.typography.subtitle1 ) Text( text = user.email, style = MaterialTheme.typography.body2, color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f) ) } } } } Why Use Compose? Less Code: No more XML layouts or view binding Preview Support: See your UI changes instantly in Android Studio Reusable Components: Easy to create and share UI components State Management: Automatic UI updates when data changes Useful Tips Break down large composables into smaller ones Use previews for quick iteration Keep state at the appropriate level Use appropriate scopes for side effects Conclusion Compose might feel different at first, but it makes UI development much more straightforward once you get used to it. Start with small components, understand how state works, and you\u0026rsquo;ll be building complex UIs in no time.\nDon\u0026rsquo;t forget to check out my other articles!\n","permalink":"https://www.codefright.com/posts/jetpack-compose/","summary":"Hey! Let\u0026rsquo;s explore Jetpack Compose and see how it makes Android UI development more enjoyable.\nWhat is Jetpack Compose? Compose is just a different way to build your app\u0026rsquo;s UI. Instead of writing XML layouts and then manipulating them with code, you write Kotlin functions that describe your UI. It\u0026rsquo;s that simple.\nGetting Started First, add these to your build.gradle:\ndependencies { implementation \u0026#34;androidx.compose.ui:ui:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.material:material:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.ui:ui-tooling-preview:1.5.4\u0026#34; } Your First Composable Let\u0026rsquo;s write something simple:","title":"⚡ Lets Explore Jetpack Compose!"},{"content":"Remember that time you needed a widget that Android doesn\u0026rsquo;t provide out of the box? Maybe a circular progress bar that looks like a pizza being eaten? Well, grab your favorite beverage, because we\u0026rsquo;re about to dive into the world of custom views!\nWhy Create Custom Views? Sometimes the standard Android widgets just don\u0026rsquo;t cut it. Maybe you need:\nA special animation effect A unique user interaction That perfect design your UI/UX team dreamed up The Basics: Anatomy of a Custom View Here\u0026rsquo;s a simple custom view that draws a circle that changes color when touched:\nclass ColorChangeCircleView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { private val paint = Paint(Paint.ANTI_ALIAS_FLAG) private var currentColor = Color.BLUE init { // Enable touch events isClickable = true } override fun onDraw(canvas: Canvas) { super.onDraw(canvas) // Get the center and radius val centerX = width / 2f val centerY = height / 2f val radius = min(width, height) / 3f // Draw the circle paint.color = currentColor canvas.drawCircle(centerX, centerY, radius, paint) } override fun onTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_DOWN -\u0026gt; { // Change color randomly currentColor = Color.rgb( Random.nextInt(256), Random.nextInt(256), Random.nextInt(256) ) invalidate() // Redraw the view return true } } return super.onTouchEvent(event) } } Understanding the View Lifecycle Measurement and Layout The view lifecycle is crucial for proper rendering. Here\u0026rsquo;s how to handle measurement and layout:\noverride fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { // Calculate the ideal size of the view based on content val desiredWidth = suggestedMinimumWidth + paddingLeft + paddingRight val desiredHeight = suggestedMinimumHeight + paddingTop + paddingBottom // Reconcile size with any constraints from the parent val finalWidth = resolveSize(desiredWidth, widthMeasureSpec) val finalHeight = resolveSize(desiredHeight, heightMeasureSpec) // Must call this to save the measurements setMeasuredDimension(finalWidth, finalHeight) } override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) { super.onSizeChanged(w, h, oldw, oldh) // Update size-dependent calculations circleRadius = min(w, h) / 3f // Update drawing bounds rect.set( paddingLeft.toFloat(), paddingTop.toFloat(), (w - paddingRight).toFloat(), (h - paddingBottom).toFloat() ) } State Management Always handle configuration changes and state restoration:\noverride fun onSaveInstanceState(): Parcelable { val superState = super.onSaveInstanceState() return Bundle().apply { putParcelable(\u0026#34;superState\u0026#34;, superState) putInt(\u0026#34;currentColor\u0026#34;, currentColor) } } override fun onRestoreInstanceState(state: Parcelable?) { val bundle = state as Bundle super.onRestoreInstanceState(bundle.getParcelable(\u0026#34;superState\u0026#34;)) currentColor = bundle.getInt(\u0026#34;currentColor\u0026#34;) invalidate() } Making It Configurable Let\u0026rsquo;s make our view configurable through XML with various attribute types:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;declare-styleable name=\u0026#34;ColorChangeCircleView\u0026#34;\u0026gt; \u0026lt;attr name=\u0026#34;circleRadius\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;defaultColor\u0026#34; format=\u0026#34;color\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;shapeStyle\u0026#34; format=\u0026#34;enum\u0026#34;\u0026gt; \u0026lt;enum name=\u0026#34;filled\u0026#34; value=\u0026#34;0\u0026#34; /\u0026gt; \u0026lt;enum name=\u0026#34;stroke\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/attr\u0026gt; \u0026lt;attr name=\u0026#34;strokeWidth\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;enableAnimation\u0026#34; format=\u0026#34;boolean\u0026#34; /\u0026gt; \u0026lt;/declare-styleable\u0026gt; \u0026lt;/resources\u0026gt; And the corresponding Kotlin implementation:\ninit { context.theme.obtainStyledAttributes( attrs, R.styleable.ColorChangeCircleView, 0, 0 ).apply { try { circleRadius = getDimension( R.styleable.ColorChangeCircleView_circleRadius, resources.getDimension(R.dimen.default_radius) ) defaultColor = getColor( R.styleable.ColorChangeCircleView_defaultColor, Color.BLUE ) shapeStyle = getInt( R.styleable.ColorChangeCircleView_shapeStyle, SHAPE_STYLE_FILLED ) strokeWidth = getDimension( R.styleable.ColorChangeCircleView_strokeWidth, resources.getDimension(R.dimen.default_stroke_width) ) enableAnimation = getBoolean( R.styleable.ColorChangeCircleView_enableAnimation, false ) } finally { recycle() } } currentColor = defaultColor } Advanced Touch Handling Implement sophisticated touch interactions using GestureDetector:\nclass ColorChangeCircleView : View { private val gestureDetector = GestureDetectorCompat(context, object : GestureDetector.SimpleOnGestureListener() { override fun onDown(e: MotionEvent): Boolean = true override fun onSingleTapUp(e: MotionEvent): Boolean { changeColor() return true } override fun onFling( e1: MotionEvent?, e2: MotionEvent, velocityX: Float, velocityY: Float ): Boolean { startSpinAnimation(velocityX) return true } }) override fun onTouchEvent(event: MotionEvent): Boolean { return gestureDetector.onTouchEvent(event) || super.onTouchEvent(event) } } Animation Integration Add smooth animations to your custom view:\nprivate fun startColorAnimation(newColor: Int) { ValueAnimator.ofArgb(currentColor, newColor).apply { duration = 300 interpolator = FastOutSlowInInterpolator() addUpdateListener { animator -\u0026gt; currentColor = animator.animatedValue as Int invalidate() } start() } } Accessibility Considerations Make your custom view accessible to all users:\ninit { // Set content description contentDescription = context.getString(R.string.color_circle_description) // Enable accessibility events importantForAccessibility = IMPORTANT_FOR_ACCESSIBILITY_YES } override fun onInitializeAccessibilityNodeInfo(info: AccessibilityNodeInfo) { super.onInitializeAccessibilityNodeInfo(info) info.className = Button::class.java.name info.isClickable = true info.addAction(AccessibilityNodeInfo.ACTION_CLICK) } Performance Tips Avoid Object Creation in onDraw() // BAD override fun onDraw(canvas: Canvas) { val paint = Paint() // Don\u0026#39;t do this! canvas.drawCircle(...) } // GOOD private val paint = Paint() // Create once in initialization override fun onDraw(canvas: Canvas) { canvas.drawCircle(...) } Use Hardware Acceleration android:hardwareAccelerated=\u0026#34;true\u0026#34; Optimize Invalidation // Only invalidate the necessary area invalidate(left, top, right, bottom) // Use post for thread-safe invalidation postInvalidate() Debugging Tips Debug draw mode: override fun onDraw(canvas: Canvas) { super.onDraw(canvas) if (BuildConfig.DEBUG) { paint.style = Paint.Style.STROKE paint.color = Color.RED canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint) } } Log measurements: override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { super.onMeasure(widthMeasureSpec, heightMeasureSpec) if (BuildConfig.DEBUG) { val widthMode = MeasureSpec.getMode(widthMeasureSpec) val widthSize = MeasureSpec.getSize(widthMeasureSpec) Log.d(TAG, \u0026#34;Width Mode: ${getModeString(widthMode)}, Size: $widthSize\u0026#34;) } } Testing Custom Views Here\u0026rsquo;s a basic test setup:\n@RunWith(AndroidJUnit4::class) class ColorChangeCircleViewTest { private lateinit var view: ColorChangeCircleView @Before fun setup() { view = ColorChangeCircleView( InstrumentationRegistry.getInstrumentation().targetContext ) } @Test fun testColorChange() { val initialColor = view.getCurrentColor() view.performClick() assertNotEquals(initialColor, view.getCurrentColor()) } } A Real-World Example: Custom Progress View Here\u0026rsquo;s a more practical example - a custom progress view that fills up like a battery:\nclass BatteryProgressView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { private var progress = 0f private val paint = Paint(Paint.ANTI_ALIAS_FLAG) private val rect = RectF() fun setProgress(value: Float) { progress = value.coerceIn(0f, 100f) invalidate() } override fun onDraw(canvas: Canvas) { super.onDraw(canvas) // Draw battery outline paint.style = Paint.Style.STROKE paint.color = Color.GRAY rect.set(0f, 0f, width.toFloat(), height.toFloat()) canvas.drawRect(rect, paint) // Draw battery level paint.style = Paint.Style.FILL paint.color = when { progress \u0026lt; 20f -\u0026gt; Color.RED progress \u0026lt; 50f -\u0026gt; Color.YELLOW else -\u0026gt; Color.GREEN } val levelWidth = (width * (progress / 100f)) rect.set(0f, 0f, levelWidth, height.toFloat()) canvas.drawRect(rect, paint) } } Resources for Further Learning Android Developer Documentation on Custom Views Android Graphics Architecture Material Design Guidelines Conclusion Custom views are like cooking - start with the basic recipe, then add your own flavors!\nStay tuned for more Android development articles!\n","permalink":"https://www.codefright.com/posts/custom-views/","summary":"Remember that time you needed a widget that Android doesn\u0026rsquo;t provide out of the box? Maybe a circular progress bar that looks like a pizza being eaten? Well, grab your favorite beverage, because we\u0026rsquo;re about to dive into the world of custom views!\nWhy Create Custom Views? Sometimes the standard Android widgets just don\u0026rsquo;t cut it. Maybe you need:\nA special animation effect A unique user interaction That perfect design your UI/UX team dreamed up The Basics: Anatomy of a Custom View Here\u0026rsquo;s a simple custom view that draws a circle that changes color when touched:","title":"⚡ Guide to Custom Views in Android"},{"content":"Hey! Lets explore Kotlin Coroutines in this post.\nWhat Are Coroutines? Think of coroutines as tiny workers in your code who can pause their work, go grab a coffee, and come back exactly where they left off. Unlike regular functions that must run to completion, coroutines can take breaks without blocking the main thread.\nWhen a coroutine \u0026ldquo;takes a break,\u0026rdquo; it\u0026rsquo;s typically doing one of several things:\nWaiting for I/O operations to complete (like reading from a file or making a network request) Yielding control to allow other coroutines to run Waiting for a timer or delay to expire Waiting for data from another coroutine or for some condition to be met The key point is that during these \u0026ldquo;breaks,\u0026rdquo; the coroutine isn\u0026rsquo;t actually consuming CPU resources. Instead, it\u0026rsquo;s in a suspended state, and the program can do other useful work.\nGetting Started First, you\u0026rsquo;ll need to add the coroutines dependency to your build.gradle:\ndependencies { implementation \u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.10.1\u0026#34; } The Basics: Your First Coroutine Let\u0026rsquo;s start with something simple:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // Launch a coroutine in the lifecycle scope lifecycleScope.launch { // This is suspended code delay(1000) // Wait for 1 second Log.d(\u0026#34;Coroutines\u0026#34;, \u0026#34;Hello from the future!\u0026#34;) } } } Understanding Dispatchers: Where Your Coroutines Run Think of dispatchers as different workspaces for your coroutines. Just like how you wouldn\u0026rsquo;t do heavy lifting in a library or read a book at a gym, different coroutines need different environments:\nsuspend fun showHowDispatchersWork() { // For CPU-intensive tasks (like sorting lists, parsing JSON) withContext(Dispatchers.Default) { val hugelist = (1..1000000).toList().shuffled() hugelist.sorted() // Heavy computation } // For network/disk operations withContext(Dispatchers.IO) { // Reading files, making API calls val data = URL(\u0026#34;https://api.example.com\u0026#34;).readText() } // For UI updates withContext(Dispatchers.Main) { binding.textView.text = \u0026#34;Updated!\u0026#34; } } Coroutine Builders: Different Ways to Launch Coroutines come with different \u0026ldquo;builders\u0026rdquo; - think of them as different tools for different jobs:\nclass CoroutineDemo { fun showDifferentBuilders() { // Fire and forget lifecycleScope.launch { Log.d(\u0026#34;Demo\u0026#34;, \u0026#34;This just runs!\u0026#34;) } // Returns a result val deferred = lifecycleScope.async { delay(1000) \u0026#34;Hello from async!\u0026#34; } // runBlocking - Mainly for testing runBlocking { val result = deferred.await() Log.d(\u0026#34;Demo\u0026#34;, result) } } } Coroutine Scopes: The Parent-Child Relationship Coroutines have a family tree. Each coroutine has a parent, and when the parent is cancelled, all its children are cancelled too. It\u0026rsquo;s like a really responsible family:\nclass MyViewModel : ViewModel() { init { viewModelScope.launch { // Parent launch { // Child 1 // Some work } launch { // Child 2 // More work } } } } The Benefits of Coroutines Why should you fall in love with coroutines? Here\u0026rsquo;s why:\nThey\u0026rsquo;re Light as a Feather: While threads might take 1MB+ of memory, coroutines only need a few bytes. You can run thousands of them without breaking a sweat!\nStructured Concurrency: Coroutines are organized in a way that makes error handling and cancellation much more predictable. When a parent coroutine is cancelled, all its children are automatically cancelled too:\nviewModelScope.launch { try { val userInfo = async { fetchUserInfo() } val userPosts = async { fetchUserPosts() } // Wait for both results displayUserProfile(userInfo.await(), userPosts.await()) } catch (e: Exception) { // Handles errors from both operations! showError(\u0026#34;Oops, something went wrong!\u0026#34;) } } Sequential by Default: Writing async code that looks like sync code is a superpower: // The old way (callbacks) fetchUserData { user -\u0026gt; fetchUserPosts(user.id) { posts -\u0026gt; fetchPostComments(posts[0].id) { comments -\u0026gt; // Welcome to callback hell! } } } // The coroutine way lifecycleScope.launch { val user = fetchUserData() val posts = fetchUserPosts(user.id) val comments = fetchPostComments(posts[0].id) // Clean and simple! } Watch Out For These! Here are some common pitfalls to watch out for:\nThe Infinite Coroutine: Don\u0026rsquo;t forget to cancel your coroutines! It could result in memory leaks.\nWrong Context: Running network calls on the main thread is like trying to juggle while riding a unicycle.\n// DON\u0026#39;T DO THIS lifecycleScope.launch(Dispatchers.Main) { // Heavy network operation api.fetchLargeData() // App freezes } // DO THIS INSTEAD lifecycleScope.launch(Dispatchers.IO) { // Heavy network operation val data = api.fetchLargeData() withContext(Dispatchers.Main) { // Update UI safely showData(data) } } The Scope Mixup: Using the wrong scope can lead to memory leaks or crashes: // DON\u0026#39;T: Using GlobalScope is like using a global variable GlobalScope.launch { // This might outlive your activity! } // DO: Use structured concurrency lifecycleScope.launch { // This gets cancelled when your activity does } The Context Switch Confusion: lifecycleScope.launch(Dispatchers.IO) { val data = fetchData() binding.textView.text = data // Crash! Can\u0026#39;t touch UI here withContext(Dispatchers.Main) { binding.textView.text = data // This is the way } } The Exception Escape: Coroutines can be sneaky with exceptions: // DON\u0026#39;T: Silent failure lifecycleScope.launch { throw Exception(\u0026#34;Boom!\u0026#34;) // Gets swallowed } // DO: Handle your exceptions lifecycleScope.launch { try { throw Exception(\u0026#34;Boom!\u0026#34;) } catch (e: Exception) { Log.e(\u0026#34;Error\u0026#34;, \u0026#34;Something went wrong\u0026#34;, e) showErrorToUser(e.message) } } Real-World Examples Image Loading Here\u0026rsquo;s a practical example of using coroutines for loading images:\nclass ImageLoader { fun loadImage(imageUrl: String, imageView: ImageView) { // Launch in the Main scope but switch to IO for network lifecycleScope.launch { try { val bitmap = withContext(Dispatchers.IO) { URL(imageUrl).openStream().use { BitmapFactory.decodeStream(it) } } // Back on Main thread imageView.setImageBitmap(bitmap) } catch (e: Exception) { // Handle error Log.e(\u0026#34;ImageLoader\u0026#34;, \u0026#34;Failed to load image\u0026#34;, e) } } } } Building a Cache+Network Data Fetcher Let\u0026rsquo;s see how coroutines shine in a real-world scenario:\nclass DataRepository { suspend fun fetchUserData(userId: String): User { // Try cache first return withContext(Dispatchers.IO) { try { val cachedUser = database.getUser(userId) if (cachedUser.isUpToDate()) { return@withContext cachedUser } // Cache miss or outdated, fetch from network val freshUser = api.fetchUser(userId) // Update cache in the background launch { database.saveUser(freshUser) } freshUser } catch (e: Exception) { // If everything fails, at least try to return cached data database.getUser(userId) ?: throw e } } } } Conclusion Understanding Coroutines might seem difficult at first, but once you get the hang of them, you\u0026rsquo;ll wonder how you ever lived without them. They provide a powerful way to handle asynchronous operations with clean, readable code that\u0026rsquo;s efficient and maintainable.\nDon\u0026rsquo;t forget to checkout my other articles!\n","permalink":"https://www.codefright.com/posts/kotlin-coroutines/","summary":"Hey! Lets explore Kotlin Coroutines in this post.\nWhat Are Coroutines? Think of coroutines as tiny workers in your code who can pause their work, go grab a coffee, and come back exactly where they left off. Unlike regular functions that must run to completion, coroutines can take breaks without blocking the main thread.\nWhen a coroutine \u0026ldquo;takes a break,\u0026rdquo; it\u0026rsquo;s typically doing one of several things:\nWaiting for I/O operations to complete (like reading from a file or making a network request) Yielding control to allow other coroutines to run Waiting for a timer or delay to expire Waiting for data from another coroutine or for some condition to be met The key point is that during these \u0026ldquo;breaks,\u0026rdquo; the coroutine isn\u0026rsquo;t actually consuming CPU resources.","title":"⚡ Kotlin Coroutines for the Beginners"},{"content":"Anu S Pillai Android | Kotlin | Flutter\n✉️ anu_icloud@icloud.com | 📍 Bangalore, India\nSummary Experienced Android and Kotlin developer with over 11 years of expertise designing, architecting and developing Android applications, SDKs and library projects. Extensive experience leading teams and delivering high-quality software solutions.\nSuccessfully developed and published over 25 apps on PlayStore, including apps with over 100K downloads, such as South Indian Bank mPassbook, Scootsy (acquired by Swiggy), Revofit (a fitness/lifestyle app backed by Marico), Wellthy Care (a chronic disease management platform, acquired by TruDoc Inc.), and Catch \u0026amp; Win - Howzzattt (a 2D game developed using AndEngine for Toonz Animation India).\nPassionate about learning and mastering new technologies and frameworks independently. Enjoys sharing knowledge through meetups, blogging, and open-source contributions. Would love to explore more of KMM and mobile LLMs.\nExperience Tech Lead - Apps and Frameworks Borqs Software Solutions, Bangalore (2023 - Present)\nLeading a team working on an array of inhouse as well as ODC projects involving Android, Kotlin, Flutter Worked as an Android / Kotlin Tech Consultant for an AAOS - Kotlin project for Qualcomm Inc. Lead a team designing and architecting a Kotlin MQTT Cloud Sync module + Flutter companion app for an overseas Android Automotive project Currently working with Meta Inc. (Facebook) for developing a Flutter based cross-platform desktop project Actively participate in code reviews and project architecture discussions. Conduct internal meetups to upskill and mentor developers Lead Software Developer - Android Wellthy Therapeutics, Bangalore (2021 - 2023)\nArchitected and developed Wellthy app and SDK for Android platform with 100K+ downloads and maintaining \u0026gt;99% weekly crash free users Lead developer responsible for architecting and developing new feature requirements Worked on Improving app user experience and timely bug fixes which resulted in PlayStore rating going up from 3.5 to 4.6 in a year Collaborated with cross-functional teams to design and develop features that met business requirements Led the team to brainstorm and implement code optimizations and features which led to a significant improvement in code reusability, modularity and maintainability Helped the organization to achieve faster development goals by introducing code templates and generators Overlooking the Sprint plans, Task prioritization and ensure timely sprint / task closure Maintaining the team\u0026rsquo;s performance scorecards, BvA analysis, setting and tracking quarterly goals Lead the Wellthy SDK development team to develop and document SDK based on Wellthy Platform Senior Software Developer - Android Wellthy Therapeutics, Bangalore (2017 - 2021)\nArchitected and developed Wellthy app for Android platform Developed and maintained mobile applications using Kotlin language Bug tracking / Fixing and timely release and team management Write and review test cases Senior Application Developer Scootsy (Acquired by Swiggy), Mumbai (2014 - 2017)\nLed the team developing Android Apps like Scootsy, Revofit, Scootsy VMS from scratch Developed and maintained mobile applications using Java Collaborated with cross-functional teams to design and develop mobile applications Developer responsible for coordinating the project. Followed Agile / Scrum development methodology Junior Android Developer Simrge, Trivandrum (2013 - 2014)\nDeveloped Android Apps like mParking Dubai, Howzzattt 2D Game using AndEngine, SIB mPassbook (Android + Blackberry), iCRM for vTiger First Android Hire. Followed Agile development Education Bachelor of Information Technology Anna University, Chennai (2008 - 2012)\nSkills Languages Kotlin (Proficient) Java (Proficient) Flutter / Dart (Advanced) KMM (Beginner) Python (Intermediate) Links Stack Overflow LinkedIn GitHub Twitter Blog Notable Contributions WELLTHY CARE (WELLTHY THERAPEUTICS) View on Play Store\nWellthy Care is the digital health coach that will help you manage diabetes, chronic kidney disease (CKD) and other such chronic conditions.\nTechnologies used: Kotlin, MVVM, Hilt, Coroutines, Retrofit with RxJava for API calls, Realm, Espresso, JUnit, AWS Mqtt SCOOTSY (ACQUIRED BY SWIGGY) View on Play Store\nScootsy is an intra-city delivery service in Mumbai that delivers from the best restaurants, food stores, book shops, toy stores, fashion outlets, gift shops, sport stores and more.\nTechnologies used: Java, SQLite, Retrofit, Socket.IO, Firebase, GraphQL SOUTH INDIAN BANK M-PASSBOOK (ANDROID / WINDOWS /BLACKBERRY) View Details\nIndia\u0026rsquo;s one of the first mobile passbook app. Track your SIB account transactions on the go. Developed for South Indian Bank. Developed for Android and Windows. Ported to Blackberry.\nTechnologies used: Java, SQLite, Retrofit, C# (for Windows app) And Many More!\n","permalink":"https://www.codefright.com/resume/","summary":"Anu S Pillai Android | Kotlin | Flutter\n✉️ anu_icloud@icloud.com | 📍 Bangalore, India\nSummary Experienced Android and Kotlin developer with over 11 years of expertise designing, architecting and developing Android applications, SDKs and library projects. Extensive experience leading teams and delivering high-quality software solutions.\nSuccessfully developed and published over 25 apps on PlayStore, including apps with over 100K downloads, such as South Indian Bank mPassbook, Scootsy (acquired by Swiggy), Revofit (a fitness/lifestyle app backed by Marico), Wellthy Care (a chronic disease management platform, acquired by TruDoc Inc.","title":""},{"content":"FlipTimerView A customizable flip animation timer library for Android, developed in Kotlin.\nSimple flip animation with customizable duration Support for days, hours, minutes and seconds http_cyclic_mocks A lightweight Dart library for mocking HTTP responses with Dio. Mock Multiple Responses for single route / endpoint.\nSupport for multiple responses per endpoint Cyclic response patterns Easy integration with existing Dio setup Perfect for testing and development KinderScript [Work in Progress] A simple terminal based child-friendly programming language for learning coding basics. Developed completely in Kotlin.\nSimple syntax for kids Built for educational purposes ","permalink":"https://www.codefright.com/projects/","summary":"FlipTimerView A customizable flip animation timer library for Android, developed in Kotlin.\nSimple flip animation with customizable duration Support for days, hours, minutes and seconds http_cyclic_mocks A lightweight Dart library for mocking HTTP responses with Dio. Mock Multiple Responses for single route / endpoint.\nSupport for multiple responses per endpoint Cyclic response patterns Easy integration with existing Dio setup Perfect for testing and development KinderScript [Work in Progress] A simple terminal based child-friendly programming language for learning coding basics.","title":"Projects"}]